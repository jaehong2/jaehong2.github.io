<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="https://jaehong2.github.io//author/jaehong/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://jaehong2.github.io//" rel="alternate" type="text/html" />
  <updated>2021-08-01T23:57:14+09:00</updated>
  <id>https://jaehong2.github.io//author/jaehong/feed.xml</id>

  
  
  

  
    <title type="html">오늘의 공부기록 | </title>
  

  
    <subtitle>기록.</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">rebase</title>
      <link href="https://jaehong2.github.io//git-rebase" rel="alternate" type="text/html" title="rebase" />
      <published>2021-08-01T06:00:00+09:00</published>
      <updated>2021-08-01T06:00:00+09:00</updated>
      <id>https://jaehong2.github.io//git-rebase</id>
      <content type="html" xml:base="https://jaehong2.github.io//git-rebase">&lt;h2 id=&quot;rebase&quot;&gt;rebase&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;A branch에서 B branch로 합칠때 Merge or rebase를 사용한다고 한다.&lt;/li&gt;
  &lt;li&gt;Merge, rebase 실행 결과는 같다. 하지만 git history가 달라진다.&lt;/li&gt;
  &lt;li&gt;Merge는 쉽다. 안전하다. 하지만 히스토리가 지저분해질 수 있다고 한다.&lt;/li&gt;
  &lt;li&gt;Rebase는 잘 못사용시 위험 할 수 있지만 history를 깔끔하게 관리 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/git/1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="git" />
      

      
        <summary type="html">rebase A branch에서 B branch로 합칠때 Merge or rebase를 사용한다고 한다. Merge, rebase 실행 결과는 같다. 하지만 git history가 달라진다. Merge는 쉽다. 안전하다. 하지만 히스토리가 지저분해질 수 있다고 한다. Rebase는 잘 못사용시 위험 할 수 있지만 history를 깔끔하게 관리 할 수 있다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Spring boot 환경 설정</title>
      <link href="https://jaehong2.github.io//tomcatport" rel="alternate" type="text/html" title="Spring boot 환경 설정" />
      <published>2021-04-08T04:10:00+09:00</published>
      <updated>2021-04-08T04:10:00+09:00</updated>
      <id>https://jaehong2.github.io//tomcatport</id>
      <content type="html" xml:base="https://jaehong2.github.io//tomcatport">&lt;h2 id=&quot;프로젝트-시작-전-환경-설정&quot;&gt;프로젝트 시작 전 환경 설정&lt;/h2&gt;

&lt;hr /&gt;
&lt;p&gt;개발 환경 : IntelliJ, Gradle&lt;/p&gt;

&lt;p&gt;@SpringBootApplication로 선언된 class 실행시&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SpringBootApplication이 tomcat을 내장하고 있어서, springBoot와 같이 실행 된다고 함
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/4.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;bulid시 gradle을 통하여 하는 거보다 intelliJ로 java를 돌리는게 더빠르다고 함! (환경설정시 확인하기!)
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/2.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;라이브러리&quot;&gt;라이브러리&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Gradle은 의존관계가 있는 라이브러리를 함께 다운로드 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;bunlid.gradle&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모듈의 빌드 방법이 정의된 빌드 스크립트(애플리케이션 버전, 라이브러리 설정)
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/5.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 현재 3개의 library만 지정해 주었지만&lt;/p&gt;

&lt;p&gt;밑에 그림 처럼 실제로는 내가 가지고 오지않은 라이브러리들이 더 많은 걸 알수있습니다.
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/6.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 gradle이나 maven 같은 빌드 툴들은 의존 관계를 관리 해준다고 함
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/7.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;starter-web의 경우 starter-tomcat이랑도 의존 관계&lt;/li&gt;
  &lt;li&gt;이처럼 starter-web을 가지고 왔지만 starter-web과 의존 관계에 있는 라이브러리들 가지고 옴&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;톰캣-포트-번호-지정&quot;&gt;톰캣 포트 번호 지정&lt;/h3&gt;
&lt;p&gt;문제 : intellij gradle 환경에서 Run시에 톰캣이 실행되않는 오류
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아마 8080 port가 사용 중이라 포트번호를 application.properties 파일에 작성해주니 제대로 실행이 되었다.
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/3.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;로깅로그&quot;&gt;로깅(로그)&lt;/h3&gt;
&lt;p&gt;로그 파일이 따로 관리가 되고 심각한 에러가 발생시에 참고 한다고 함
Sysout 대신 log를 사용하는 습관을 들이자!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/8.jpg&quot; alt=&quot;Alt text&quot; /&gt;
slf4j는 인터페이스, 실제 로그를 어떤 구현체로 출력할지는 logback을 사용한다고함.&lt;br /&gt;
이 두가지 조합을 많이 사용한다고 함.&lt;/p&gt;

&lt;h3 id=&quot;테스트-라이브러리&quot;&gt;테스트 라이브러리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;junit5 : 테스트 라이브러리&lt;/li&gt;
  &lt;li&gt;mockito : 목 라이브러리&lt;/li&gt;
  &lt;li&gt;assertj : 테스트 코드를 좀 더 편한하게 도와주는 라이브러리&lt;/li&gt;
  &lt;li&gt;spring-test : 스프링 통합 테스트 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;view-환경설정&quot;&gt;View 환경설정&lt;/h3&gt;

&lt;h4 id=&quot;welcome-page-기능&quot;&gt;Welcome Page 기능&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features&quot;&gt;SpringBoot 문서&lt;/a&gt;
&lt;img src=&quot;/assets/built/images/spring_inflearn/spring-start/9.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;정적 컨텐츠를 위한 index.html 파일을 찾는 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;
&lt;p&gt;[인프런 김영한님 강의]&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">프로젝트 시작 전 환경 설정</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 03 27 정규 표현식</title>
      <link href="https://jaehong2.github.io//pt-12-1" rel="alternate" type="text/html" title="21 03 27 정규 표현식" />
      <published>2021-03-25T19:37:00+09:00</published>
      <updated>2021-03-25T19:37:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-12-1</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-12-1">&lt;h2 id=&quot;정규-표현식regular-expressions&quot;&gt;정규 표현식(Regular expressions)&lt;/h2&gt;
&lt;p&gt;줄여서 Regex 라고 표현&lt;br /&gt;
Regex는 문자열에 어떤 패턴의 문자들이 있는지 찾는데 도움을 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;metacharacters&quot;&gt;Metacharacters&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Metacharacters&lt;/strong&gt;는 정규표현식의 패턴에서 어떤 문자가 특별한 의미를 갖는 것을 말합니다.&lt;br /&gt;
예를 들어, \d는 0에서 9사이의 숫자를 의미합니다.
&lt;img src=&quot;/assets/built/images/pt/week_12/2.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;quantifiers&quot;&gt;Quantifiers.&lt;/h3&gt;
&lt;p&gt;Quantifiers는 요소들을 얼마나 반복시킬지 정의합니다.&lt;br /&gt;
&lt;img src=&quot;/assets/built/images/pt/week_12/3.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;grouping&quot;&gt;Grouping&lt;/h3&gt;
&lt;p&gt;패턴에 그룹을 지정할 수 있습니다.
그룹은 ()로 지정하며, 
그룹을 표현할 때는 $1처럼 $다음에 그룹의 번호를 입력합니다. 
패턴에서 가장 왼쪽 그룹이 1번으로 시작합니다.&lt;/p&gt;

&lt;h3 id=&quot;자주사용하는-정규-표현식&quot;&gt;자주사용하는 정규 표현식&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_12/1.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;정규-표현식-작성방법&quot;&gt;정규 표현식 작성방법&lt;/h2&gt;
&lt;p&gt;정규 표현식을 작성하는 방법은 java API의 java.util.regex 패키지 사용&lt;br /&gt;
패키지안에 Pattern Class와 Matcher Class 주로 사용&lt;/p&gt;

&lt;p&gt;** 1. Pattern 클래스 **&lt;/p&gt;

&lt;h2 id=&quot;주요-메서드&quot;&gt;주요 메서드&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.regex.Pattern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RegexExample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
            &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;^[0-9]*$&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;12345&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
        
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pattern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pattern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;** 2. Pattern 클래스 **&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정리&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;
&lt;p&gt;[학교에서 알려주지 않는 17가지 실무 개발 기술]&lt;br /&gt;
&lt;a href=&quot;https://coding-factory.tistory.com/529&quot;&gt;https://coding-factory.tistory.com/529&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">정규 표현식(Regular expressions) 줄여서 Regex 라고 표현 Regex는 문자열에 어떤 패턴의 문자들이 있는지 찾는데 도움을 줍니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 03 20 날짜와 시간</title>
      <link href="https://jaehong2.github.io//pt-11-1" rel="alternate" type="text/html" title="21 03 20 날짜와 시간" />
      <published>2021-03-15T19:37:00+09:00</published>
      <updated>2021-03-15T19:37:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-11-1</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-11-1">&lt;h2 id=&quot;날짜와-시간&quot;&gt;날짜와 시간&lt;/h2&gt;
&lt;p&gt;프로그램이 사용하는 시간의 종류와 단위, 나라마다 다른 시차를 어떻게 처리해야하는지 알아보자!&lt;/p&gt;

&lt;h3 id=&quot;타임스탬프&quot;&gt;타임스탬프&lt;/h3&gt;
&lt;p&gt;컴퓨터가 시간을 표현하기위해 사용하는 값&lt;br /&gt;
1970년 1월 1일 0시 0분 0초 부터 1초 단위로 증가&lt;br /&gt;
1초보다 작은시간(milli,micro)을 타임스탬프의 소수점 자리값으로 가져올수도있음.  &lt;br /&gt;
그러나 모든 컴퓨터가 1초보다 작은 시간 단위를 지원하는것은 아니라고함&lt;br /&gt;
&lt;img src=&quot;/assets/built/images/pt/week_11/1.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;단조시간과-실제시간&quot;&gt;단조시간과 실제시간&lt;/h3&gt;
&lt;p&gt;컴퓨터가 타임스탬프로 표현할수 있는 시간은 두 종류가 있습니다.&lt;br /&gt;
하나는 &lt;strong&gt;단조시간&lt;/strong&gt;으로 컴퓨터가 직접계산하는 시간&lt;br /&gt;
다른하나는 우리가 사용하는 세계의 &lt;em&gt;*실제 시간&lt;/em&gt;입니다.&lt;br /&gt;
사용용도가 서로다르다고 함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단조시간&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제 or CPU와 같은 하드웨어에서 직접 계산하는 시간&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불변성을 보장하는 시간 값이 필요할때 사용&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;ex)예를들어 어떤 작업을 10초 또는 1분마다 수행해야될때(동일한 주기로 작업)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;운영체제가 시작한 이후 시점 부터 바뀌지 않은 특징이 있음 -&amp;gt; 사용자가 값을 변경 불가능&lt;/li&gt;
  &lt;li&gt;시스템 재부팅 이후에는 값이 초기화&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;실제시간&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;실제시간은 벽 시계 시간이라고 부르기도합니다. 우리가 흔히아는 아날로그 시계&lt;/li&gt;
  &lt;li&gt;물론 실제시간도 컴퓨터가 계산은 하지만&lt;br /&gt;
주기적으로 서버로 부터 값을 가져와 동기화 하기에 시간이 언제든 바뀔수 있습니다.&lt;br /&gt;
그래서 단조시간 처럼 일정한 간격의 시간을 측정하기 위해서 사용하기에는 힘듭니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실제시간은 실제 세계값과 시간이 일치하기에 한달이 넘는 주기로 수행해야하는 작업에 효율적입니다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;매달 1일, 특정 날짜에 반드시 실행되야 되는 작업&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;물론 단조시간으로도 한달을 잴 수 있지만, 한달에 마지막 일(28,29,30,31,윤달..)의 다양함    &lt;br /&gt;
단조시간으로 하면 처리할 부분 증가&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;실제 시간 사용시 주의점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;실제시간은 &lt;strong&gt;외부 환경에 의해서 값이 언제든바뀔수있습니다&lt;/strong&gt;. 시작 값이 잘못설정되어있으면
작업이 끝나는 시간도 잘못되기때문입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;그래서 많은 사용 서비스들이 운영체제 구성 단계부터 &lt;strong&gt;모두 같은 서버를 사용하게끔 설정하여&lt;/strong&gt;,&lt;br /&gt;
시간값이 서로 &lt;strong&gt;동기화 되어있는지&lt;/strong&gt; 주기적으로 확인&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;타임존&quot;&gt;타임존&lt;/h3&gt;
&lt;p&gt;실제시간을 사용때는 타임존 설정을 꼭 확인!&lt;br /&gt;
여러 국가를 대상하는 서비스를 개발할때 반드시 타입존을 확인 
나라마다 표준 시간이 다르기 때문
ex)한국은 UTC+9시간을 기준으로 시간을 표현함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;타임존 설정을 유의해야하는 이유&lt;/strong&gt;&lt;br /&gt;
하나의 서버에서 여러 프로그램이 실행하는 경우라면 문제가 없지만
여러 서버가 서로 다른 타임 존을 사용하는데는 문제가 생길 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를들어 A서버는 UTC+9, B서버는 UTC+0를 사용한다고 가정
&lt;img src=&quot;/assets/built/images/pt/week_11/2.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A서버는 오후 9시에 작업을 수행하도록 요청 했지만&lt;br /&gt;
B서버는 UTC+0시간을 기준으로 하기에 18시간 뒤에 작업이 수행되는걸 볼 수 있습니다.&lt;br /&gt;
위와 같이 두서버간의 차이로 발생한 문제를 방지하기위해&lt;br /&gt;
여러 프로그램이나 서버간 동일한 타임존 사용!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;정리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단조시간은 실제 시간으로 사용할 수 없지만, 불변성을 보장함으로 시간의 차이를 표현할때 사용
    &lt;ul&gt;
      &lt;li&gt;특정 작업을 수행하는데 걸린 시간을 측정할때&lt;/li&gt;
      &lt;li&gt;일정한 주기(한달 미만)로 작업을 수행할때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실제 시간은 매달 1일 또는 특정 날짜인지 확인 할때(이를 확인한 작업은의 간격은 단조시간 사용해야됨)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실제 시간을 표기할때&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;실제 시간 값은 서비스를 구성하는 모든서버와 프로그램이 UTC를 사용 또는 동일한 타임존 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;
&lt;p&gt;[학교에서 알려주지 않는 17가지 실무 개발 기술]&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">날짜와 시간 프로그램이 사용하는 시간의 종류와 단위, 나라마다 다른 시차를 어떻게 처리해야하는지 알아보자!</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 03 13 문자열 인코딩</title>
      <link href="https://jaehong2.github.io//pt-10-1" rel="alternate" type="text/html" title="21 03 13 문자열 인코딩" />
      <published>2021-03-11T21:03:00+09:00</published>
      <updated>2021-03-11T21:03:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-10-1</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-10-1">&lt;h2 id=&quot;문자열-인코딩character-encoding-이란&quot;&gt;문자열 인코딩(Character encoding) 이란.&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;2진법을 사용하는 컴퓨터가 인간의 언어를 일정한 규칙에 따라 2진수로 변환하는 방식&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;아스키 코드&lt;/li&gt;
    &lt;li&gt;EUR-KR&lt;/li&gt;
    &lt;li&gt;UTF-8, 16, 32&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;문자열 인코딩 방식에서 여러 규칙 중 어느 것을 적용 하는지에 따라 &lt;br /&gt;
글자가 올바르게 표현 될 수도 있고 &lt;strong&gt;깨져서 보일 수도&lt;/strong&gt; 있다.
&lt;img src=&quot;/assets/built/images/pt/week_10/3.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림3&quot; /&gt;
깨지는 이유는??&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;컴퓨터-인코딩의-역사&quot;&gt;컴퓨터 인코딩의 역사&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_10/1.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;br /&gt;
&lt;strong&gt;처음 컴퓨터가&lt;/strong&gt; 등장 할때는 &lt;strong&gt;영어, 특수문자만 지원&lt;/strong&gt; 해주었다고 한다.
그러면서 &lt;strong&gt;여러 나라로 컴퓨터가 전파&lt;/strong&gt;되면서 &lt;strong&gt;국가별로 사용하는 언어를 표현하고자&lt;/strong&gt;
독자적인 규칙을 만들었다고 한다.
그리고 모든 언어를 같은 규칙으로 표현할 수 있는 유니코드 방식이 등장했지만&lt;/p&gt;

&lt;p&gt;&lt;em&gt;모든 개발환경이 유니코드를 동일하게 처리하지 않아,&lt;/em&gt; &lt;br /&gt;
&lt;em&gt;개발자는 서로 호환되지 않는 유니코드 문자열 인코딩 방식(UTF-8, 16, 32) 중 하나를 택해야 합니다&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;그리고 한국에는 유니코드가 등장하기 전 만든 인코딩 방식(EUC-KR)을 쓰는 오래된 시스템도 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;아스키-코드ascii&quot;&gt;아스키 코드(ASCII)&lt;/h3&gt;
&lt;p&gt;아스키 코드 (American Standard Code for Information Interchange)&lt;br /&gt;
&lt;img src=&quot;/assets/built/images/pt/week_10/2.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림2&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;처음&lt;/em&gt;으로 표준을 정립한 문자열 인코딩 방식으로 아직까지 많이 사용&lt;/li&gt;
  &lt;li&gt;대,소문자 아라비아 숫자, 공백 및 특수 문자가 있음&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;0~127&lt;/em&gt; 까지 총 128개 숫자 사용&lt;/li&gt;
  &lt;li&gt;문자하나를 표현하기위해 &lt;em&gt;1 Byte&lt;/em&gt; 사용&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;영어를 제외한 다른 언어를 표현 할 수 없다.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;eur-kr&quot;&gt;EUR-KR&lt;/h3&gt;
&lt;p&gt;EUC-KR은 한국 산업 표준으로 지정된 한국어 문자 집합&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한글 하나를 표현하기 위해 &lt;em&gt;2 Byte&lt;/em&gt; 사용&lt;/li&gt;
  &lt;li&gt;아스키 코드는 1Byte 사용하기에 아스키 코드와 호환 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_10/4.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림4&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;빈곳을 포함해서 가로로 총 16개의 문자&lt;/li&gt;
  &lt;li&gt;가장 왼쪽에 있는 코드(B0A0, B0B0)을 기준으로 오른쪽으로 한칸 이동시 1바이트씩 더함&lt;/li&gt;
  &lt;li&gt;예를 들어 ‘가’를 표현하면 B0A1로 표현하고, B0A1는 0x&lt;strong&gt;B0&lt;/strong&gt;,0x&lt;strong&gt;A1&lt;/strong&gt;로 나뉘어 2바이트가 사용됨&lt;/li&gt;
  &lt;li&gt;완성형 코드이기 때문에 표현할 수 없는 한글 글자가 있음&lt;/li&gt;
  &lt;li&gt;실제 보여지는 문자열 길이와 컴퓨터가 할당하는 버퍼의 크기는 다를 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;유니코드&quot;&gt;유니코드&lt;/h3&gt;
&lt;p&gt;EUR-KR처럼 국가별로 독자적인 문자 집합과 인코딩 방식은&lt;br /&gt;
&lt;strong&gt;개발자 업무량 증가&lt;/strong&gt;될 것이다.&lt;br /&gt;
이런 문제를 해결하고자 국제 표준화 기구(ISO)에서 유니코드를 만들었다.&lt;/p&gt;

&lt;p&gt;유니코드 문자 집합을 표현하는 문자열 인코딩은 세가지&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;UTF-8&lt;/li&gt;
  &lt;li&gt;UTF-16&lt;/li&gt;
  &lt;li&gt;UTF-32&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;utf-8&quot;&gt;UTF-8&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;UTF-8은 &lt;em&gt;8비트(1Byte)로 인코딩&lt;/em&gt; 하는 것을 의미&lt;/li&gt;
  &lt;li&gt;표현하려는 문자에 따라 최소 1Byte ~ 6Byte까지 사용이 가능&lt;/li&gt;
  &lt;li&gt;아스키 코드와 완벽하게 호환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_10/5.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림5&quot; /&gt;
그림에서 ‘바이트 수’ 행의 값은 문자를 표현하는데 총 바이트 크기를 나타내고&lt;br /&gt;
1 ~ 6 바이트 까지 있는 1과 0은 고정된 비트 값이며, 사용하는 바이트 수 에 따라 달라집니다.&lt;br /&gt;
‘x’ 문자는 유니코드를 저장하는데 사용되는 비트의 영역 입니다.&lt;/p&gt;

&lt;p&gt;그림에서 첫번째 줄(1Byte)에서  첫째 비트 값이 0 이므로 
0을 제외한 나머지 비트 7개로 문자를 표현합니다.&lt;br /&gt;
그래서 0~127까지의 수로 문자를 표현 할 수 있고&lt;br /&gt;
&lt;em&gt;아스키 코드와 같은 규칙&lt;/em&gt;을 가지므로 &lt;em&gt;UTF-8과 아스키 코드는 완벽하게 호환&lt;/em&gt;된다고도 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그리고 보통 일반적인 문자는 3Byte 내로 처리가능&lt;br /&gt;
4 Byte 영역은 이모지(에모지)&lt;br /&gt;
5 Byte 부터는 고대 문자를 사용하지 않는이상 사용할일이 없습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;utf-16&quot;&gt;UTF-16&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;UTF-16은 2Byte로 인코딩하는 것을 말함&lt;/li&gt;
  &lt;li&gt;2Byte, 4Byte 만 사용 하기에 아스키 코드와 호환되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;유니코드에는 문자 종류에 따라 4가지로 나뉨&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;기본 다국어 평면(BMP)&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;보충 다국어 평면(SMP)&lt;/li&gt;
  &lt;li&gt;상형 문자 보충 평면(SIP)&lt;/li&gt;
  &lt;li&gt;특수 목적 보충 평면(SSP)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;바이트 수는 문자가 어떤 평면에 속하는지에 따라 결정됨&lt;br /&gt;
ex) BMP같은경우 U+0000 ~ U+FFFF까지 범위에 속하는 문자가 있는데&lt;br /&gt;
이 범위에는 한글, 한자를 포함한 여러 다국어가 있고 2Byte로 인코딩 합니다.&lt;br /&gt;
정리하면 UTF-16은 일반 글자는 2Byte,&lt;br /&gt;
특별한 글자(쐐기 문자, 키프로스 음절문자 …)는 4Byte를 사용해 인코딩합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;정리&quot;&gt;정리&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;UTF - 8&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;오늘날 가장 많이 사용하는 문자열 인코딩&lt;/li&gt;
  &lt;li&gt;최소 1 ~ 6 Byte 사용(대부분 4Byte내로 처리)&lt;/li&gt;
  &lt;li&gt;아스키 코드와 호환 가능&lt;/li&gt;
  &lt;li&gt;JSON은 UTF-8 인코딩만 사용함, 다른 문자열은 지원하지않음&lt;/li&gt;
  &lt;li&gt;? 윈도우,자바 임베디드를 제외한 거의 모든환경에서 문자열 처리 표준&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;UTF - 16&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;자바와 윈도우는 유니코드를 사용하기 전 부터 고정된 2바이트 길이의 문자 집합 사용&lt;/li&gt;
  &lt;li&gt;2 Byte, 4 Byte 길이의 문자열 사용, 때문에 아스키와 호환이 안됨&lt;/li&gt;
  &lt;li&gt;UTF - 16기반 환경에서 UTF - 8을 사용할때는 명확한 구분이 필요함
예를들어 자바기반 웹서비스는 UTF - 16을 사용하되, 외부(DB) 통신 시 UTF-8로 변환하여 사용하는걸 추천&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;UTF - 32&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;반드시 사용해야 하는 환경이 아니라면 권장하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;EUC-KR&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;한국에서 독자적으로 사용하는 문자열 인코딩방식&lt;/li&gt;
  &lt;li&gt;고정된 2Byte 사용&lt;/li&gt;
  &lt;li&gt;가능하다면 UTF-8로 바꾸어 사용하는게 좋지만 현실적으로 어려움이 존재&lt;/li&gt;
  &lt;li&gt;국내에서 만든 서비스 중 EUC-KR을 사용하는 경우가 있을 수 있음.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;
&lt;p&gt;[학교에서 알려주지 않는 17가지 실무 개발 기술]&lt;br /&gt;
&lt;a href=&quot;https://m.blog.naver.com/bbmobile/221360230141&quot;&gt;https://m.blog.naver.com/bbmobile/221360230141&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">문자열 인코딩(Character encoding) 이란. 2진법을 사용하는 컴퓨터가 인간의 언어를 일정한 규칙에 따라 2진수로 변환하는 방식 아스키 코드 EUR-KR UTF-8, 16, 32</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 03 06 (서블릿, JSP)</title>
      <link href="https://jaehong2.github.io//pt-9-2" rel="alternate" type="text/html" title="21 03 06 (서블릿, JSP)" />
      <published>2021-03-03T23:03:00+09:00</published>
      <updated>2021-03-03T23:03:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-9-2</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-9-2">&lt;h3 id=&quot;1-서블릿servlet&quot;&gt;1. 서블릿(Servlet)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;클라이언트의 요청을 처리하고, 그 결과를 반환하는  &lt;br /&gt;
Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;서블릿의-특징&quot;&gt;서블릿의 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트&lt;/li&gt;
  &lt;li&gt;MVC 패턴에서 Controller로 이용된다.&lt;/li&gt;
  &lt;li&gt;Java Thread를 이용하여 동작한다.&lt;/li&gt;
  &lt;li&gt;HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.&lt;/li&gt;
  &lt;li&gt;html을 사용하여 요청에 응답 할 수 있다.&lt;/li&gt;
  &lt;li&gt;HTML 변경 시 Servlet을 재컴파일해야 하는 단점이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;2서블릿-컨테이너servlet-container&quot;&gt;2.서블릿 컨테이너(Servlet Container)&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;서블릿을 관리해주는 컨테이너&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;서블릿을 만들었다고 해서 스스로작동하는 것이 아니고, &lt;strong&gt;서블릿을 제어 해주는 역할&lt;/strong&gt;이 필요한데, 
그 역할을 서블릿 컨테이너가 가짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;서블릿-컨테이너의-역할&quot;&gt;서블릿 컨테이너의 역할&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 웹서버와의 통신&lt;/strong&gt;
서블릿 컨테이너는 서블릿과 웹서버가 손쉽게 통신할 수 있게 해줍니다. 일반적으로 우리는 소켓을 만들고 listen, 
accept 등을 해야하지만 서블릿 컨테이너는 이러한 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해줍니다.
그래서 개발자가 서블릿에 구현해야 할 &lt;strong&gt;비지니스 로직에 대해서 집중 할 수있게 도와줍니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 서블릿 생명주기(Life Cycle 관리)&lt;/strong&gt;&lt;br /&gt;
서블릿의 시작과 끝을 관리합니다.
&lt;img src=&quot;/assets/built/images/pt/week_9/2-1.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;요청받음 : 클라이언트가 서비스 요청시 &lt;strong&gt;HTTP 프로토콜 기반으로 요청정보가 만들어져 웹서버&lt;/strong&gt;에 전달&lt;/li&gt;
  &lt;li&gt;웹서버에서 컨테이너 : 웹서버에서는 전달 받은 요청을 살펴보고 &lt;strong&gt;요청받은 정보가 서블릿이라면 서블릿 컨테이너&lt;/strong&gt;에게 넘김&lt;/li&gt;
  &lt;li&gt;URL 매핑 확인 : &lt;strong&gt;서블릿 매핑이 담긴 문서(web.xml or @WebServlet)를 참조&lt;/strong&gt;하여 어떤 URL과 매핑되었는지 확인하고&lt;/li&gt;
  &lt;li&gt;최초 요청 여부 판단 : 매핑된 서블릿을 실행하는데 컨테이너는 해당 &lt;strong&gt;서블릿이 메모리에 있는지 확인&lt;/strong&gt;하고&lt;/li&gt;
  &lt;li&gt;서블릿 객체 생성 : 최초의 서블릿이라면 해당 &lt;strong&gt;서블릿을 메모리에 로딩하고 서블릿 객체&lt;/strong&gt;를 생성합니다.&lt;/li&gt;
  &lt;li&gt;init() 메소드 실행 : init()은 서블릿객체가 생성된 다음에 호출되는 메소드로 서블릿객체의 &lt;strong&gt;초기화 작업&lt;/strong&gt;이 구현되있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HttpRequest,Response 객체 생성&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Service 메소드 실행 : Service 메서드는 &lt;strong&gt;HTTP 요청의 METHOD에 대응되는 메서드를 호출&lt;/strong&gt;한다.(form tag에서 method 부분)&lt;/li&gt;
  &lt;li&gt;destroy 메소드 실행 : 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 &lt;strong&gt;소멸&lt;/strong&gt;시킵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;jspjava-server-page&quot;&gt;JSP(Java Server Page)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JSP란 HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구&lt;/li&gt;
  &lt;li&gt;JSP는 WAS(Web Application Server)에 의하여 서블릿 클래스로 변환하여 사용됨&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jsp-동작-과정&quot;&gt;JSP 동작 과정&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_9/2-3.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림3&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;클라이언트로 JSP 파일 요청이 들어오면 .java(Servlet)파일로 &lt;strong&gt;변환(Translation)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴파일&lt;/strong&gt;하여 .class 파일이 만들어짐&lt;/li&gt;
  &lt;li&gt;컴파일된 서블릿 클래스는 서블릿 컨테이너에 의해서 서블릿 객체로 동작.&lt;/li&gt;
  &lt;li&gt;jspInit, jspService, jspDestory 과정 실행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;## References.&lt;br /&gt;
&lt;a href=&quot;https://mangkyu.tistory.com/14&quot;&gt;https://mangkyu.tistory.com/14&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://hackr.io/blog/jsp-interview-questions&quot;&gt;https://hackr.io/blog/jsp-interview-questions&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://altera520.github.io/posts&quot;&gt;https://altera520.github.io/posts&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">1. 서블릿(Servlet)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 03 06</title>
      <link href="https://jaehong2.github.io//pt-9-1" rel="alternate" type="text/html" title="21 03 06" />
      <published>2021-03-03T22:03:00+09:00</published>
      <updated>2021-03-03T22:03:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-9-1</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-9-1">&lt;h2 id=&quot;톰캣-버전별-차이&quot;&gt;톰캣 버전별 차이&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_9/1.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Each version of Tomcat is supported for any stable Java release 
that meets the requirements of the final column in the table above.  &lt;br /&gt;
(표에 맞는 Java Version 이상을 사용해야 안정적인 Tomcat 동작을 지원한다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;apache-tomcat-7x&quot;&gt;Apache Tomcat 7.X&lt;/h3&gt;
  &lt;ul&gt;
    &lt;li&gt;Please note that although we offer downloads and documentation of older releases,
such as Apache Tomcat 7.x, we strongly encourage users to use the latest stable version of
Apache Tomcat whenever possible.&lt;br /&gt;
(요약 : 7 버전 쓰지마세요.)&lt;br /&gt;
&lt;b&gt;개선 사항&lt;/b&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Servlet 3.0, JSP 2.2, EL 2.2 and WebSocket 1.1&lt;/strong&gt; 사양 구현&lt;/li&gt;
    &lt;li&gt;웹 응용 프로그램 메모리 누수 감지 및 예방&lt;/li&gt;
    &lt;li&gt;CSRF 보호&lt;/li&gt;
    &lt;li&gt;Manager 및 Host Manager 응용 프로그램의 향상된 보안&lt;/li&gt;
    &lt;li&gt;리팩토링 (커넥터, 라이프 사이클) 및 많은 내부 코드 정리&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;apache-tomcat-8x&quot;&gt;Apache Tomcat 8.X&lt;/h3&gt;
&lt;h4 id=&quot;80x&quot;&gt;8.0.X&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Servlet 3.1 , JSP 2.3 , EL 3.0 및 WebSocket 1.1&lt;/strong&gt; 사양 구현&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;현재 Tomcat 8.0은 8.5로 대체&lt;/strong&gt;, 8.0을 쓰고있다면 8.5로 마이그레이션 하세요!&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;85x&quot;&gt;8.5.X&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Tomcat 8.0.X과 동일한 사양 지원, 또한 &lt;strong&gt;JASPIC 1.1 규격도 구현&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;HTTP/2에 대한 지원 추가(Tomcat Native 라이브러리 필요)&lt;/li&gt;
  &lt;li&gt;JSSE 커넥터(NIO 및 NIO2)에서 TLS 지원을 위한 OpenSSL 사용 지원 추가&lt;/li&gt;
  &lt;li&gt;TLS 가상 호스팅(SNI) 지원 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;85에서-제거-된-기술&quot;&gt;8.5에서 제거 된 기술&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP 및 AJP 커넥터의 BIO 구현&lt;/li&gt;
  &lt;li&gt;Comet API 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;apache-tomcat-9x&quot;&gt;Apache Tomcat 9.X&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Servlet 4.0 지원&lt;/li&gt;
  &lt;li&gt;Http / 2에 지원 추가&lt;/li&gt;
  &lt;li&gt;JSE 커넥터(NIO 및 NIO2)에서 OpenSSL을 TLS 지원용으로 사용하기 위한 지원 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;apache-tomcat-10x&quot;&gt;Apache Tomcat 10.X&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Servlet 5.0 , JSP 3.0 , EL 4.0, WebSocket 2.0, Authentication 2.0&lt;/strong&gt; 사양 구현&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## References.&lt;br /&gt;
&lt;a href=&quot;http://tomcat.apache.org/whichversion.html&quot;&gt;톰캣 공식사이트&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">톰캣 버전별 차이 Each version of Tomcat is supported for any stable Java release that meets the requirements of the final column in the table above. (표에 맞는 Java Version 이상을 사용해야 안정적인 Tomcat 동작을 지원한다.)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 02 27</title>
      <link href="https://jaehong2.github.io//pt-8" rel="alternate" type="text/html" title="21 02 27" />
      <published>2021-02-26T22:03:00+09:00</published>
      <updated>2021-02-26T22:03:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-8</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-8">&lt;h2 id=&quot;주제--백트레킹-mvc패턴&quot;&gt;주제 : 백트레킹, Mvc패턴&lt;/h2&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;백트레킹이란&quot;&gt;백트레킹이란&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 노드의 &lt;strong&gt;유망성을 판단&lt;/strong&gt; 후 노드가 유망하지 않다면 부모 노드로 돌아가&lt;br /&gt;
다른 자식 노드를 찾는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;baekjoon-n과-m1&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15649&quot;&gt;BaekJoon N과 M(1)&lt;/a&gt;&lt;/h3&gt;

&lt;h4 id=&quot;문제&quot;&gt;문제&lt;/h4&gt;

&lt;p&gt;자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열&lt;/p&gt;

&lt;h4 id=&quot;입력&quot;&gt;입력&lt;/h4&gt;
&lt;p&gt;첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)&lt;/p&gt;
&lt;h4 id=&quot;출력&quot;&gt;출력&lt;/h4&gt;
&lt;p&gt;한 줄에 하나씩 문제의 조건을 만족하는 &lt;strong&gt;수열을 출력&lt;/strong&gt;한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.
수열은 &lt;strong&gt;사전 순으로 증가하는 순서&lt;/strong&gt;로 출력해야 한다.&lt;/p&gt;

&lt;p&gt;예제 입력&lt;/p&gt;
&lt;pre&gt;3 1&lt;/pre&gt;
&lt;p&gt;예제 출력&lt;/p&gt;
&lt;pre&gt;
1   
2  
3
&lt;/pre&gt;

&lt;p&gt;예제 입력&lt;/p&gt;
&lt;pre&gt;4 3&lt;/pre&gt;
&lt;p&gt;예제 출력&lt;/p&gt;
&lt;pre&gt;
1 2 3  
1 2 4  
1 3 2  
1 3 4  
1 4 2  
1 4 3  
2 1 3  
2 1 4  
2 3 1  
2 3 4  
2 4 1  
2 4 3  
3 1 2  
3 1 4  
3 2 1  
3 2 4  
3 4 1  
3 4 2  
4 1 2  
4 1 3  
4 2 1  
4 2 3  
4 3 1  
4 3 2  
&lt;/pre&gt;

&lt;h4 id=&quot;문제-분석&quot;&gt;문제 분석&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;중복되는 수를 제외한 모든 경우의수 탐색&lt;/li&gt;
  &lt;li&gt;재귀사용, 방문한 노드 라면 다음 노드 탐색(유망성 검사)&lt;/li&gt;
  &lt;li&gt;재귀함수임으로 기저조건(BaseCondition) 명시&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;코드&quot;&gt;코드&lt;/h4&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.io.*&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.io.*&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.StringTokenizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[];&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//수열을 담을 배열&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 특정 수가 사용되었는지 &lt;/span&gt;
		
		&lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
		&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

	
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// 재귀함수임으로 기저조건(BaseCondition) 명시&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// m개까지 탐색을 완료하면 SB에 수열 저장&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// 부모 노드로 돌아간다.&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		
		&lt;span class=&quot;c1&quot;&gt;//1부터 n까지 사용되지않은 수를 찾아냄&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]){&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
				&lt;span class=&quot;n&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;mvc1-mvc2-spring-frame에서-mvc2-패턴&quot;&gt;MVC1, MVC2, Spring Frame에서 MVC2 패턴&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_8/1.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;소프트웨어 디자인 패턴 중하나&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;M(Model) / V(View) / C(Controller)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Model : &lt;strong&gt;내부 비지니스 로직을 처리&lt;/strong&gt;하기 위한 역할을 할 것입니다. (DB 접근)
        &lt;ul&gt;
          &lt;li&gt;처리되는 알고리즘, DB 와 상호작용(CRUD Create Read Update Delete), 데이터 등등..&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;View : &lt;strong&gt;화면에 보여주기 위한 역할&lt;/strong&gt;을 합니다. 
컨트롤러 하위에 종속되어, 모델이나 컨트롤러가 보여주려고 하는 모든 필요한 것들을 보여줄 것입니다.
        &lt;ul&gt;
          &lt;li&gt;최종 사용자에게 화면(UI)으로 보여줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Controller : 데이터와 비즈니스 로직 사이의 상호 동작을 관리합니다. 
즉, &lt;strong&gt;모델과 뷰를 통제&lt;/strong&gt;합니다. MVC 패턴에서 View와 Model이 직접적인 상호 소통을 하지 않도록 관리합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;MVC 패턴은 크게 &lt;strong&gt;MVC 1&lt;/strong&gt; 패턴과, 스프링이 채택한 &lt;strong&gt;MVC 2 패턴&lt;/strong&gt;으로 나눌 수 있습니다.&lt;/p&gt;
&lt;h3 id=&quot;mvc1&quot;&gt;MVC1&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_8/2.jpg&quot; alt=&quot;At text&quot; title=&quot;그림2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;MVC1 패턴의 경우 View와 Controller를 모두 JSP가 담당하는 형태를 가집니다.&lt;br /&gt;
즉 JSP 하나로 유저의 요청을 받고 응답을 처리하므로 &lt;strong&gt;구현 난이도는 쉽습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;단순한 프로젝트에는 괜찮겠지만 &lt;strong&gt;내용이 복잡하고 거대해질수록&lt;/strong&gt; 이 패턴은 &lt;strong&gt;힘을 잃습니다&lt;/strong&gt;.
JSP 하나에서 MVC 가 모두 이루어지다보니 &lt;strong&gt;재사용성도 매우 떨어지고, 읽기도 힘들어집니다. 즉 유지보수에 있어서 문제&lt;/strong&gt;가 발생합니다.&lt;/p&gt;

&lt;h3 id=&quot;mvc2&quot;&gt;MVC2&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_8/3.jpg&quot; alt=&quot;At text&quot; title=&quot;그림3&quot; /&gt;
MVC2 패턴은 널리 표준으로 사용되는 패턴, &lt;strong&gt;요청을 하나의 컨트롤러(Servlet)&lt;/strong&gt;가 먼저 받습니다. 
즉 MVC1과는 다르게 &lt;strong&gt;Controller, View&lt;/strong&gt;가 분리되어 있습니다. 
따라서 역할이 분리되어 MVC1패턴에서의 단점을 보완할 수 있습니다. 
그러므로 개발자는 M, V, C 중에서 수정해야 할 부분이 있다면, 그것만 꺼내어 수정하면 됩니다. 따라서 &lt;strong&gt;유지보수에 있어서도 큰 이점&lt;/strong&gt;을 가집니다.&lt;/p&gt;

&lt;h3 id=&quot;spring-framkework에서-mvc2-패턴&quot;&gt;Spring FramkeWork에서 MVC2 패턴&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_8/5.jpg&quot; alt=&quot;At text&quot; title=&quot;그림5&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;요청이 들어오면 DispatcherServlet이 받고 요청내용을 HandlerMapping 에게 보냄&lt;/li&gt;
  &lt;li&gt;HandlerMapping에서는 가장 적합한 Controller 찾음&lt;/li&gt;
  &lt;li&gt;Controller 안에 적합한 메서드를 찾아 ModelAndView형식으로 return&lt;/li&gt;
  &lt;li&gt;ViewResolver는 결과에 해당하는 jsp 리턴 후 클라이언트에게 jsp 응답&lt;/li&gt;
  &lt;li&gt;http 관계 끊어짐&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;## References.&lt;br /&gt;
&lt;a href=&quot;https://tinkerbellbass.tistory.com/40&quot;&gt;https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC&lt;/a&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/15649&quot;&gt;https://www.acmicpc.net/problem/15649&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">주제 : 백트레킹, Mvc패턴</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 02 06</title>
      <link href="https://jaehong2.github.io//pt-5" rel="alternate" type="text/html" title="21 02 06" />
      <published>2021-02-05T02:03:00+09:00</published>
      <updated>2021-02-05T02:03:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-5</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-5">&lt;h2 id=&quot;주제--http-09--20&quot;&gt;주제 : http 0.9 ~ 2.0&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;http-09--20&quot;&gt;HTTP 0.9 ~ 2.0&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_5/1.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;http-09&quot;&gt;HTTP 0.9&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_5/2.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림2&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;요청과 응답이 심플, 확장성이 없음&lt;/li&gt;
  &lt;li&gt;원 라인 프로토콜이라고도 불림&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;http-10&quot;&gt;HTTP 1.0&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_5/3.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림3&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Header가 추가됨(버전, 상태코드, Content-Type Header)&lt;/li&gt;
  &lt;li&gt;특징 : 1 Connection == 1 Request &amp;amp; 1 Response&lt;/li&gt;
  &lt;li&gt;문제점 : 요청당 Connection 발생(성능저하, 비용증가)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;http-11&quot;&gt;HTTP 1.1&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Persistent Connection&lt;/strong&gt; : 지정한 timeout 동안 Connection을 닫지 않는 방식
&lt;img src=&quot;/assets/built/images/pt/week_5/4.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림4&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Pipelining&lt;/strong&gt; : 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을
                   연속적으로 보내 순서에 맞춰 응답 받는 방식 (시간 절감)&lt;br /&gt;
&lt;img src=&quot;/assets/built/images/pt/week_5/5.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림5&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;문제점&lt;/strong&gt;   &lt;br /&gt;
&lt;img src=&quot;/assets/built/images/pt/week_5/6.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림6&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;첫번째요청이 처리하는 시간이 오래걸리면 두번째요청부터는 기다려야함&lt;/li&gt;
  &lt;li&gt;연속된 요청일 경우 중복 Header 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;http-20&quot;&gt;HTTP 2.0&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기존 HTTP/1.X 버전의 &lt;strong&gt;성능 향상&lt;/strong&gt;에 초점&lt;/li&gt;
  &lt;li&gt;표준의 대체가 아닌 &lt;strong&gt;확장&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http-20-특징&quot;&gt;HTTP 2.0 특징&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. Http 메세지 전송 방식의 변화&lt;/strong&gt;
&lt;img src=&quot;/assets/built/images/pt/week_5/7.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림7&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;바이너리 프레이밍 계층 사용 -&amp;gt; 파싱,전송 속도 증가, 오류 발생 가능성 낮아짐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_5/8.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림8&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Stream : 연결된 커넥션 사이에서 바이트의 양방향 흐름. 하나 또는 하나 이상의 message를 전송함&lt;/li&gt;
  &lt;li&gt;Message : 프레임들의 완성된 배열. Request/Response의 논리적인 배열이라고 보면 된다.&lt;/li&gt;
  &lt;li&gt;Frame : HTTP/2.0 통신에서 가장 작은 단위의 유닛.&lt;br /&gt;
각각의 frame 은 헤더를 포함하고 있음. 헤더는 현재 전송되는 프레임이 어디에 포함되는 것인지 알려주는 최소 단위.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. Request &amp;amp; Response Multiplexing&lt;/strong&gt;
&lt;img src=&quot;/assets/built/images/pt/week_5/8.5.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림8.5&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;요청과 응답이 다중화가 가능해짐&lt;/li&gt;
  &lt;li&gt;Frame으로 쪼개짐으로서 메세지간의 순서가 사라짐&lt;/li&gt;
  &lt;li&gt;1.1에서 Head Of Line Blocking 문제 해결&lt;/li&gt;
  &lt;li&gt;interleaving(끼워넣기) 방식 또한 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. Stream Prioritization&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리소스간의 전송 우선순위를 설정&lt;/li&gt;
  &lt;li&gt;각 스트림에는 1~256 사이의 정수 가중치가 할당될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;각 스트림에는 다른 스트림에 대한 명시적 종속성이 부여될 수 있습니다.
&lt;img src=&quot;/assets/built/images/pt/week_5/9.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림9&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4. Server push&lt;/strong&gt;
&lt;img src=&quot;/assets/built/images/pt/week_5/10.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림10&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트가 요청 하지 않은 리소스들을 서버에서 자동 푸쉬&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5. 헤더 압축(Header Compression)&lt;/strong&gt;
&lt;img src=&quot;/assets/built/images/pt/week_5/11.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림11&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기존 1.1에서는 header의 중복에 문제가 있었는데 2.0에서 해결&lt;/li&gt;
  &lt;li&gt;Static dynamic table 도입(중복된 내용은 인덱스만 뽑고, 새로추가된 내용은 허프만 인코딩으로 압축)&lt;/li&gt;
  &lt;li&gt;헤더의 크기를 줄여 페이지 로드 시간 감소&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC&quot;&gt;https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AC&lt;/a&gt;
&lt;a href=&quot;https://ijbgo.tistory.com/26&quot;&gt;https://ijbgo.tistory.com/26&lt;/a&gt;
&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/HTTP&quot;&gt;https://developer.mozilla.org/ko/docs/Web/HTTP&lt;/a&gt;
&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/http2?hl=ko&quot;&gt;https://developers.google.com/web/fundamentals/performance/http2?hl=ko&lt;/a&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=xcrjamphIp4&quot;&gt;https://www.youtube.com/watch?v=xcrjamphIp4&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">주제 : http 0.9 ~ 2.0</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">21 01 30</title>
      <link href="https://jaehong2.github.io//pt-4" rel="alternate" type="text/html" title="21 01 30" />
      <published>2021-01-28T01:43:00+09:00</published>
      <updated>2021-01-28T01:43:00+09:00</updated>
      <id>https://jaehong2.github.io//pt-4</id>
      <content type="html" xml:base="https://jaehong2.github.io//pt-4">&lt;h2 id=&quot;주제--tcp-udp&quot;&gt;주제 : TCP, UDP&lt;/h2&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;4계층-transport-layer&quot;&gt;4계층 Transport Layer&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/2.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림2&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;End Point 간의 데이터 &lt;strong&gt;전송&lt;/strong&gt;을 담당하는 계층&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;tcp-transmission-control-protocol&quot;&gt;TCP (Transmission Control Protocol)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;있는 데이터 통신을 가능하게 해주는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tcp-특징&quot;&gt;TCP 특징&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Connection 연결 (3 way-handshake)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;흐름제어(Flow Control) : &lt;strong&gt;데이터 처리 속도를 조절&lt;/strong&gt;하여 수신자의 버퍼 오버플로우를 방지&lt;/li&gt;
  &lt;li&gt;혼잡제어(Congestion Control) : &lt;strong&gt;네트워크 내의 패킷 수&lt;/strong&gt;가 넘치게 증가하지 않도록 방지&lt;/li&gt;
  &lt;li&gt;오류감지(Error Detection) : &lt;strong&gt;데이터 전달 중 오류 발생&lt;/strong&gt;시 해당 데이터 &lt;strong&gt;재전송&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;세그먼트segment&quot;&gt;세그먼트(Segment)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/123.png&quot; alt=&quot;Alt text&quot; title=&quot;그림1&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로토콜단 에서 데이터가 처리되고 이동하고 하는데 이때 처리되는 단위를 세그먼트&lt;/li&gt;
  &lt;li&gt;데이터를 전송 받으면 tcp 프로토콜안에서 데이터를 자르고 &lt;strong&gt;TCP Header&lt;/strong&gt;를 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tcp-header&quot;&gt;TCP Header&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/3.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림3&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-way-handshake&quot;&gt;3-way handshake&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 
먼저 &lt;strong&gt;정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정&lt;/strong&gt;을 의미한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3-way-handshake-과정&quot;&gt;3-way handshake 과정&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/4.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림4&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;[STEP 1]&lt;br /&gt;
클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 
이때 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 되는 것이다.&lt;/li&gt;
  &lt;li&gt;[STEP 2]&lt;br /&gt;
서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다.&lt;br /&gt;
이때 서버는 SYN_RECEIVED 상태가 된다.&lt;/li&gt;
  &lt;li&gt;[STEP 3]&lt;br /&gt;
클라이언트는 서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tcp-데이터-전송-방식&quot;&gt;TCP 데이터 전송 방식&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/8.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림8&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-way-handshkae-과정&quot;&gt;4-way handshkae 과정&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/5.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림5&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;[STEP 1]&lt;br /&gt;
클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.&lt;/li&gt;
  &lt;li&gt;[STEP 2]&lt;br /&gt;
서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 TIME_WAIT상태다.&lt;/li&gt;
  &lt;li&gt;[STEP 3]&lt;br /&gt;
서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.&lt;/li&gt;
  &lt;li&gt;[STEP 4]&lt;br /&gt;
클라이언트는 확인했다는 메시지를 보낸다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;tcp-문제점&quot;&gt;TCP 문제점&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;신뢰성있는 전송은 보장하지만..&lt;/li&gt;
  &lt;li&gt;매번 Connection 연결 -&amp;gt; 시간적 손실&lt;/li&gt;
  &lt;li&gt;패킷을 조금만 손실해도 재전송&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;udp&quot;&gt;UDP&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;TCP 보단 &lt;strong&gt;신뢰성이 떨어&lt;/strong&gt;지지만 &lt;strong&gt;전송 속도가 빠른&lt;/strong&gt; 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;udp-특징&quot;&gt;UDP 특징&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Connectionless(3 way-handshake x)&lt;/li&gt;
  &lt;li&gt;오류감지(Error Delection)&lt;/li&gt;
  &lt;li&gt;비교적 데이터의 신뢰성이 중요하지 않을때 사용(ex. 영상 스트리밍)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;udp-header&quot;&gt;UDP Header&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/6.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림6&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;udp-데이터-전송-방식&quot;&gt;UDP 데이터 전송 방식&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/assets/built/images/pt/week_4/7.jpg&quot; alt=&quot;Alt text&quot; title=&quot;그림7&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;정리&quot;&gt;정리&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;TCP와 UDP 모두 Header가 존재&lt;/li&gt;
  &lt;li&gt;포트 번호를 이용해서 데이터를 전달, 데이터 오류 검사를 위한 Checksum이 존재&lt;/li&gt;
  &lt;li&gt;TCP는 연결이 성공해야 통신이 가능(연결형 프로토콜), 3-way-handshake&lt;/li&gt;
  &lt;li&gt;UDP는 연결 없이 통신 가능 (비연결형 프로토콜)&lt;/li&gt;
  &lt;li&gt;신뢰도를 생각한다면 TCP 속도가 중요하면 UDP&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;</content>

      
      
      
      
      

      <author>
          <name>jaehong</name>
        
        
      </author>

      

      
        <category term="pt" />
      

      
        <summary type="html">주제 : TCP, UDP</summary>
      

      
      
    </entry>
  
</feed>
