<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/>

    <!-- 웹폰트 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css"/>


    <!-- syntax.css 추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="기록." />
    <link rel="shortcut icon" href="https://JaeHong2.github.io//assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://JaeHong2.github.io//search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="오늘의 공부기록" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="기록." />
    <meta property="og:url" content="https://JaeHong2.github.io//search" />
    <meta property="og:image" content="https://JaeHong2.github.io//assets/built/images/main-image.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="기록." />
    <meta name="twitter:url" content="https://JaeHong2.github.io//" />
    <meta name="twitter:image" content="https://JaeHong2.github.io//assets/built/images/main-image.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="오늘의 공부기록" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "오늘의 공부기록",
        "logo": "https://JaeHong2.github.io//"
    },
    "url": "https://JaeHong2.github.io//search",
    "image": {
        "@type": "ImageObject",
        "url": "https://JaeHong2.github.io//assets/built/images/main-image.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://JaeHong2.github.io//search"
    },
    "description": "기록."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://JaeHong2.github.io//">오늘의 공부기록</a>
            
        
        
            <!-- 메뉴 바-->
<ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <!--<li class="nav-about" role="menuitem"><a href="/about/">About</a></li>-->
    <li class="nav-python" role="menuitem"><a href="/tag/algorithm/">Algorithm</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/git/">Git</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/java/">Java</a>
    <li class="nav-python" role="menuitem"><a href="/tag/spring/">Spring</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/pt/">Pt</a></li>
    <!--<li class="nav-python" role="menuitem"><a href="/tag/etc/">Etc</a></li>-->
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "git-rebase": {
        "title": "rebase",
            "author": "jaehong",
            "category": "",
            "content": "rebase  A branch에서 B branch로 합칠때 Merge or rebase를 사용한다고 한다.  Merge, rebase 실행 결과는 같다. 하지만 git history가 달라진다.  Merge는 쉽다. 안전하다. 하지만 히스토리가 지저분해질 수 있다고 한다.  Rebase는 잘 못사용시 위험 할 수 있지만 history를 깔끔하게 관리 할 수 있다.",
        "url": "/git-rebase"
    }
    ,
    
    "tomcatport": {
        "title": "Spring boot 환경 설정",
            "author": "jaehong",
            "category": "",
            "content": "프로젝트 시작 전 환경 설정개발 환경 : IntelliJ, Gradle@SpringBootApplication로 선언된 class 실행시  SpringBootApplication이 tomcat을 내장하고 있어서, springBoot와 같이 실행 된다고 함bulid시 gradle을 통하여 하는 거보다 intelliJ로 java를 돌리는게 더빠르다고 함! (환경설정시 확인하기!)라이브러리Gradle은 의존관계가 있는 라이브러리를 함께 다운로드 한다.bunlid.gradle  모듈의 빌드 방법이 정의된 빌드 스크립트(애플리케이션 버전, 라이브러리 설정)여기서 현재 3개의 library만 지정해 주었지만밑에 그림 처럼 실제로는 내가 가지고 오지않은 라이브러리들이 더 많은 걸 알수있습니다.여기서 gradle이나 maven 같은 빌드 툴들은 의존 관계를 관리 해준다고 함  starter-web의 경우 starter-tomcat이랑도 의존 관계  이처럼 starter-web을 가지고 왔지만 starter-web과 의존 관계에 있는 라이브러리들 가지고 옴톰캣 포트 번호 지정문제 : intellij gradle 환경에서 Run시에 톰캣이 실행되않는 오류아마 8080 port가 사용 중이라 포트번호를 application.properties 파일에 작성해주니 제대로 실행이 되었다.로깅(로그)로그 파일이 따로 관리가 되고 심각한 에러가 발생시에 참고 한다고 함Sysout 대신 log를 사용하는 습관을 들이자!slf4j는 인터페이스, 실제 로그를 어떤 구현체로 출력할지는 logback을 사용한다고함.이 두가지 조합을 많이 사용한다고 함.테스트 라이브러리  junit5 : 테스트 라이브러리  mockito : 목 라이브러리  assertj : 테스트 코드를 좀 더 편한하게 도와주는 라이브러리  spring-test : 스프링 통합 테스트 지원View 환경설정Welcome Page 기능SpringBoot 문서  정적 컨텐츠를 위한 index.html 파일을 찾는 기능References.[인프런 김영한님 강의]",
        "url": "/tomcatport"
    }
    ,
    
    "pt-12-1": {
        "title": "21 03 27 정규 표현식",
            "author": "jaehong",
            "category": "",
            "content": "정규 표현식(Regular expressions)줄여서 Regex 라고 표현Regex는 문자열에 어떤 패턴의 문자들이 있는지 찾는데 도움을 줍니다.MetacharactersMetacharacters는 정규표현식의 패턴에서 어떤 문자가 특별한 의미를 갖는 것을 말합니다.예를 들어, \\d는 0에서 9사이의 숫자를 의미합니다.Quantifiers.Quantifiers는 요소들을 얼마나 반복시킬지 정의합니다.Grouping패턴에 그룹을 지정할 수 있습니다.그룹은 ()로 지정하며, 그룹을 표현할 때는 $1처럼 $다음에 그룹의 번호를 입력합니다. 패턴에서 가장 왼쪽 그룹이 1번으로 시작합니다.자주사용하는 정규 표현식정규 표현식 작성방법정규 표현식을 작성하는 방법은 java API의 java.util.regex 패키지 사용패키지안에 Pattern Class와 Matcher Class 주로 사용** 1. Pattern 클래스 **주요 메서드import java.util.regex.Pattern;public class RegexExample {\tpublic static void main(String[] args)  {                String pattern = \"^[0-9]*$\";            String val = \"12345\";                     boolean regex = Pattern.matches(pattern, val);            System.out.println(regex);    }}** 2. Pattern 클래스 **정리References.[학교에서 알려주지 않는 17가지 실무 개발 기술]https://coding-factory.tistory.com/529",
        "url": "/pt-12-1"
    }
    ,
    
    "pt-11-1": {
        "title": "21 03 20 날짜와 시간",
            "author": "jaehong",
            "category": "",
            "content": "날짜와 시간프로그램이 사용하는 시간의 종류와 단위, 나라마다 다른 시차를 어떻게 처리해야하는지 알아보자!타임스탬프컴퓨터가 시간을 표현하기위해 사용하는 값1970년 1월 1일 0시 0분 0초 부터 1초 단위로 증가1초보다 작은시간(milli,micro)을 타임스탬프의 소수점 자리값으로 가져올수도있음.  그러나 모든 컴퓨터가 1초보다 작은 시간 단위를 지원하는것은 아니라고함단조시간과 실제시간컴퓨터가 타임스탬프로 표현할수 있는 시간은 두 종류가 있습니다.하나는 단조시간으로 컴퓨터가 직접계산하는 시간다른하나는 우리가 사용하는 세계의 *실제 시간입니다.사용용도가 서로다르다고 함단조시간  운영체제 or CPU와 같은 하드웨어에서 직접 계산하는 시간  불변성을 보장하는 시간 값이 필요할때 사용          ex)예를들어 어떤 작업을 10초 또는 1분마다 수행해야될때(동일한 주기로 작업)        운영체제가 시작한 이후 시점 부터 바뀌지 않은 특징이 있음 -&gt; 사용자가 값을 변경 불가능  시스템 재부팅 이후에는 값이 초기화실제시간  실제시간은 벽 시계 시간이라고 부르기도합니다. 우리가 흔히아는 아날로그 시계  물론 실제시간도 컴퓨터가 계산은 하지만주기적으로 서버로 부터 값을 가져와 동기화 하기에 시간이 언제든 바뀔수 있습니다.그래서 단조시간 처럼 일정한 간격의 시간을 측정하기 위해서 사용하기에는 힘듭니다.  실제시간은 실제 세계값과 시간이 일치하기에 한달이 넘는 주기로 수행해야하는 작업에 효율적입니다.          매달 1일, 특정 날짜에 반드시 실행되야 되는 작업      물론 단조시간으로도 한달을 잴 수 있지만, 한달에 마지막 일(28,29,30,31,윤달..)의 다양함    단조시간으로 하면 처리할 부분 증가실제 시간 사용시 주의점      실제시간은 외부 환경에 의해서 값이 언제든바뀔수있습니다. 시작 값이 잘못설정되어있으면작업이 끝나는 시간도 잘못되기때문입니다.        그래서 많은 사용 서비스들이 운영체제 구성 단계부터 모두 같은 서버를 사용하게끔 설정하여,시간값이 서로 동기화 되어있는지 주기적으로 확인  타임존실제시간을 사용때는 타임존 설정을 꼭 확인!여러 국가를 대상하는 서비스를 개발할때 반드시 타입존을 확인 나라마다 표준 시간이 다르기 때문ex)한국은 UTC+9시간을 기준으로 시간을 표현함타임존 설정을 유의해야하는 이유하나의 서버에서 여러 프로그램이 실행하는 경우라면 문제가 없지만여러 서버가 서로 다른 타임 존을 사용하는데는 문제가 생길 수 있습니다.예를들어 A서버는 UTC+9, B서버는 UTC+0를 사용한다고 가정A서버는 오후 9시에 작업을 수행하도록 요청 했지만B서버는 UTC+0시간을 기준으로 하기에 18시간 뒤에 작업이 수행되는걸 볼 수 있습니다.위와 같이 두서버간의 차이로 발생한 문제를 방지하기위해여러 프로그램이나 서버간 동일한 타임존 사용!정리  단조시간은 실제 시간으로 사용할 수 없지만, 불변성을 보장함으로 시간의 차이를 표현할때 사용          특정 작업을 수행하는데 걸린 시간을 측정할때      일정한 주기(한달 미만)로 작업을 수행할때        실제 시간은 매달 1일 또는 특정 날짜인지 확인 할때(이를 확인한 작업은의 간격은 단조시간 사용해야됨)      실제 시간을 표기할때    실제 시간 값은 서비스를 구성하는 모든서버와 프로그램이 UTC를 사용 또는 동일한 타임존 사용References.[학교에서 알려주지 않는 17가지 실무 개발 기술]",
        "url": "/pt-11-1"
    }
    ,
    
    "pt-10-1": {
        "title": "21 03 13 문자열 인코딩",
            "author": "jaehong",
            "category": "",
            "content": "문자열 인코딩(Character encoding) 이란.  2진법을 사용하는 컴퓨터가 인간의 언어를 일정한 규칙에 따라 2진수로 변환하는 방식      아스키 코드    EUR-KR    UTF-8, 16, 32  문자열 인코딩 방식에서 여러 규칙 중 어느 것을 적용 하는지에 따라 글자가 올바르게 표현 될 수도 있고 깨져서 보일 수도 있다.깨지는 이유는??컴퓨터 인코딩의 역사처음 컴퓨터가 등장 할때는 영어, 특수문자만 지원 해주었다고 한다.그러면서 여러 나라로 컴퓨터가 전파되면서 국가별로 사용하는 언어를 표현하고자독자적인 규칙을 만들었다고 한다.그리고 모든 언어를 같은 규칙으로 표현할 수 있는 유니코드 방식이 등장했지만모든 개발환경이 유니코드를 동일하게 처리하지 않아, 개발자는 서로 호환되지 않는 유니코드 문자열 인코딩 방식(UTF-8, 16, 32) 중 하나를 택해야 합니다.그리고 한국에는 유니코드가 등장하기 전 만든 인코딩 방식(EUC-KR)을 쓰는 오래된 시스템도 있습니다.아스키 코드(ASCII)아스키 코드 (American Standard Code for Information Interchange)  처음으로 표준을 정립한 문자열 인코딩 방식으로 아직까지 많이 사용  대,소문자 아라비아 숫자, 공백 및 특수 문자가 있음  0~127 까지 총 128개 숫자 사용  문자하나를 표현하기위해 1 Byte 사용  영어를 제외한 다른 언어를 표현 할 수 없다.EUR-KREUC-KR은 한국 산업 표준으로 지정된 한국어 문자 집합  한글 하나를 표현하기 위해 2 Byte 사용  아스키 코드는 1Byte 사용하기에 아스키 코드와 호환 가능  빈곳을 포함해서 가로로 총 16개의 문자  가장 왼쪽에 있는 코드(B0A0, B0B0)을 기준으로 오른쪽으로 한칸 이동시 1바이트씩 더함  예를 들어 ‘가’를 표현하면 B0A1로 표현하고, B0A1는 0xB0,0xA1로 나뉘어 2바이트가 사용됨  완성형 코드이기 때문에 표현할 수 없는 한글 글자가 있음  실제 보여지는 문자열 길이와 컴퓨터가 할당하는 버퍼의 크기는 다를 수 있다.유니코드EUR-KR처럼 국가별로 독자적인 문자 집합과 인코딩 방식은개발자 업무량 증가될 것이다.이런 문제를 해결하고자 국제 표준화 기구(ISO)에서 유니코드를 만들었다.유니코드 문자 집합을 표현하는 문자열 인코딩은 세가지  UTF-8  UTF-16  UTF-32UTF-8  UTF-8은 8비트(1Byte)로 인코딩 하는 것을 의미  표현하려는 문자에 따라 최소 1Byte ~ 6Byte까지 사용이 가능  아스키 코드와 완벽하게 호환그림에서 ‘바이트 수’ 행의 값은 문자를 표현하는데 총 바이트 크기를 나타내고1 ~ 6 바이트 까지 있는 1과 0은 고정된 비트 값이며, 사용하는 바이트 수 에 따라 달라집니다.‘x’ 문자는 유니코드를 저장하는데 사용되는 비트의 영역 입니다.그림에서 첫번째 줄(1Byte)에서  첫째 비트 값이 0 이므로 0을 제외한 나머지 비트 7개로 문자를 표현합니다.그래서 0~127까지의 수로 문자를 표현 할 수 있고아스키 코드와 같은 규칙을 가지므로 UTF-8과 아스키 코드는 완벽하게 호환된다고도 할 수 있습니다.그리고 보통 일반적인 문자는 3Byte 내로 처리가능4 Byte 영역은 이모지(에모지)5 Byte 부터는 고대 문자를 사용하지 않는이상 사용할일이 없습니다.UTF-16  UTF-16은 2Byte로 인코딩하는 것을 말함  2Byte, 4Byte 만 사용 하기에 아스키 코드와 호환되지 않습니다.유니코드에는 문자 종류에 따라 4가지로 나뉨  기본 다국어 평면(BMP)  보충 다국어 평면(SMP)  상형 문자 보충 평면(SIP)  특수 목적 보충 평면(SSP)바이트 수는 문자가 어떤 평면에 속하는지에 따라 결정됨ex) BMP같은경우 U+0000 ~ U+FFFF까지 범위에 속하는 문자가 있는데이 범위에는 한글, 한자를 포함한 여러 다국어가 있고 2Byte로 인코딩 합니다.정리하면 UTF-16은 일반 글자는 2Byte,특별한 글자(쐐기 문자, 키프로스 음절문자 …)는 4Byte를 사용해 인코딩합니다.정리UTF - 8  오늘날 가장 많이 사용하는 문자열 인코딩  최소 1 ~ 6 Byte 사용(대부분 4Byte내로 처리)  아스키 코드와 호환 가능  JSON은 UTF-8 인코딩만 사용함, 다른 문자열은 지원하지않음  ? 윈도우,자바 임베디드를 제외한 거의 모든환경에서 문자열 처리 표준UTF - 16  자바와 윈도우는 유니코드를 사용하기 전 부터 고정된 2바이트 길이의 문자 집합 사용  2 Byte, 4 Byte 길이의 문자열 사용, 때문에 아스키와 호환이 안됨  UTF - 16기반 환경에서 UTF - 8을 사용할때는 명확한 구분이 필요함예를들어 자바기반 웹서비스는 UTF - 16을 사용하되, 외부(DB) 통신 시 UTF-8로 변환하여 사용하는걸 추천UTF - 32  반드시 사용해야 하는 환경이 아니라면 권장하지 않음EUC-KR  한국에서 독자적으로 사용하는 문자열 인코딩방식  고정된 2Byte 사용  가능하다면 UTF-8로 바꾸어 사용하는게 좋지만 현실적으로 어려움이 존재  국내에서 만든 서비스 중 EUC-KR을 사용하는 경우가 있을 수 있음.References.[학교에서 알려주지 않는 17가지 실무 개발 기술]https://m.blog.naver.com/bbmobile/221360230141",
        "url": "/pt-10-1"
    }
    ,
    
    "pt-9-2": {
        "title": "21 03 06 (서블릿, JSP)",
            "author": "jaehong",
            "category": "",
            "content": "1. 서블릿(Servlet)  클라이언트의 요청을 처리하고, 그 결과를 반환하는  Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술서블릿의 특징  클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트  MVC 패턴에서 Controller로 이용된다.  Java Thread를 이용하여 동작한다.  HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.  html을 사용하여 요청에 응답 할 수 있다.  HTML 변경 시 Servlet을 재컴파일해야 하는 단점이 있다.2.서블릿 컨테이너(Servlet Container)  서블릿을 관리해주는 컨테이너  서블릿을 만들었다고 해서 스스로작동하는 것이 아니고, 서블릿을 제어 해주는 역할이 필요한데, 그 역할을 서블릿 컨테이너가 가짐서블릿 컨테이너의 역할1. 웹서버와의 통신서블릿 컨테이너는 서블릿과 웹서버가 손쉽게 통신할 수 있게 해줍니다. 일반적으로 우리는 소켓을 만들고 listen, accept 등을 해야하지만 서블릿 컨테이너는 이러한 기능을 API로 제공하여 복잡한 과정을 생략할 수 있게 해줍니다.그래서 개발자가 서블릿에 구현해야 할 비지니스 로직에 대해서 집중 할 수있게 도와줍니다.2. 서블릿 생명주기(Life Cycle 관리)서블릿의 시작과 끝을 관리합니다.  요청받음 : 클라이언트가 서비스 요청시 HTTP 프로토콜 기반으로 요청정보가 만들어져 웹서버에 전달  웹서버에서 컨테이너 : 웹서버에서는 전달 받은 요청을 살펴보고 요청받은 정보가 서블릿이라면 서블릿 컨테이너에게 넘김  URL 매핑 확인 : 서블릿 매핑이 담긴 문서(web.xml or @WebServlet)를 참조하여 어떤 URL과 매핑되었는지 확인하고  최초 요청 여부 판단 : 매핑된 서블릿을 실행하는데 컨테이너는 해당 서블릿이 메모리에 있는지 확인하고  서블릿 객체 생성 : 최초의 서블릿이라면 해당 서블릿을 메모리에 로딩하고 서블릿 객체를 생성합니다.  init() 메소드 실행 : init()은 서블릿객체가 생성된 다음에 호출되는 메소드로 서블릿객체의 초기화 작업이 구현되있습니다.  HttpRequest,Response 객체 생성  Service 메소드 실행 : Service 메서드는 HTTP 요청의 METHOD에 대응되는 메서드를 호출한다.(form tag에서 method 부분)  destroy 메소드 실행 : 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.JSP(Java Server Page)  JSP란 HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구  JSP는 WAS(Web Application Server)에 의하여 서블릿 클래스로 변환하여 사용됨JSP 동작 과정  클라이언트로 JSP 파일 요청이 들어오면 .java(Servlet)파일로 변환(Translation)  컴파일하여 .class 파일이 만들어짐  컴파일된 서블릿 클래스는 서블릿 컨테이너에 의해서 서블릿 객체로 동작.  jspInit, jspService, jspDestory 과정 실행## References.https://mangkyu.tistory.com/14https://hackr.io/blog/jsp-interview-questionshttps://altera520.github.io/posts",
        "url": "/pt-9-2"
    }
    ,
    
    "pt-9-1": {
        "title": "21 03 06",
            "author": "jaehong",
            "category": "",
            "content": "톰캣 버전별 차이  Each version of Tomcat is supported for any stable Java release that meets the requirements of the final column in the table above.  (표에 맞는 Java Version 이상을 사용해야 안정적인 Tomcat 동작을 지원한다.)  Apache Tomcat 7.X      Please note that although we offer downloads and documentation of older releases,such as Apache Tomcat 7.x, we strongly encourage users to use the latest stable version ofApache Tomcat whenever possible.(요약 : 7 버전 쓰지마세요.)개선 사항    Servlet 3.0, JSP 2.2, EL 2.2 and WebSocket 1.1 사양 구현    웹 응용 프로그램 메모리 누수 감지 및 예방    CSRF 보호    Manager 및 Host Manager 응용 프로그램의 향상된 보안    리팩토링 (커넥터, 라이프 사이클) 및 많은 내부 코드 정리  Apache Tomcat 8.X8.0.X  Servlet 3.1 , JSP 2.3 , EL 3.0 및 WebSocket 1.1 사양 구현  현재 Tomcat 8.0은 8.5로 대체, 8.0을 쓰고있다면 8.5로 마이그레이션 하세요!8.5.X  Tomcat 8.0.X과 동일한 사양 지원, 또한 JASPIC 1.1 규격도 구현한다.  HTTP/2에 대한 지원 추가(Tomcat Native 라이브러리 필요)  JSSE 커넥터(NIO 및 NIO2)에서 TLS 지원을 위한 OpenSSL 사용 지원 추가  TLS 가상 호스팅(SNI) 지원 추가8.5에서 제거 된 기술  HTTP 및 AJP 커넥터의 BIO 구현  Comet API 지원Apache Tomcat 9.X  Servlet 4.0 지원  Http / 2에 지원 추가  JSE 커넥터(NIO 및 NIO2)에서 OpenSSL을 TLS 지원용으로 사용하기 위한 지원 추가Apache Tomcat 10.X  Servlet 5.0 , JSP 3.0 , EL 4.0, WebSocket 2.0, Authentication 2.0 사양 구현## References.톰캣 공식사이트",
        "url": "/pt-9-1"
    }
    ,
    
    "pt-8": {
        "title": "21 02 27",
            "author": "jaehong",
            "category": "",
            "content": "주제 : 백트레킹, Mvc패턴백트레킹이란  어떤 노드의 유망성을 판단 후 노드가 유망하지 않다면 부모 노드로 돌아가다른 자식 노드를 찾는 방법BaekJoon N과 M(1)문제자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.  1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.예제 입력3 1예제 출력1   2  3예제 입력4 3예제 출력1 2 3  1 2 4  1 3 2  1 3 4  1 4 2  1 4 3  2 1 3  2 1 4  2 3 1  2 3 4  2 4 1  2 4 3  3 1 2  3 1 4  3 2 1  3 2 4  3 4 1  3 4 2  4 1 2  4 1 3  4 2 1  4 2 3  4 3 1  4 3 2  문제 분석  중복되는 수를 제외한 모든 경우의수 탐색  재귀사용, 방문한 노드 라면 다음 노드 탐색(유망성 검사)  재귀함수임으로 기저조건(BaseCondition) 명시코드import java.io.*import java.io.*import java.util.StringTokenizer;public class Main {\tpublic static int arr[];\tpublic static boolean visit[];\tpublic static StringBuilder sb = new StringBuilder();\tpublic static void main(String args[]) throws IOException {\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\t\tStringTokenizer st = new StringTokenizer(br.readLine());\t\tint N = Integer.parseInt(st.nextToken());\t\tint M = Integer.parseInt(st.nextToken());\t\tarr = new int[M]; //수열을 담을 배열\t\tvisit = new boolean[N]; // 특정 수가 사용되었는지 \t\t\t\tdfs(N, M, 0); \t\tSystem.out.println(sb);\t}\t\tpublic static void dfs(int N, int M, int depth) {\t\t// 재귀함수임으로 기저조건(BaseCondition) 명시\t\tif(depth == M) { // m개까지 탐색을 완료하면 SB에 수열 저장\t\t\tfor(int val : arr) {\t\t\t\tsb.append(val).append(' ');\t\t\t}\t\t\tsb.append('\\n');\t\t\t// 부모 노드로 돌아간다.\t\t\treturn;\t\t}\t\t\t\t//1부터 n까지 사용되지않은 수를 찾아냄\t\tfor(int i=0; i &lt; N; i++) {\t\t\tif(!visit[i]){\t\t\t\tvisit[i] = true;\t\t\t\tarr[depth] = i+1;\t\t\t\tdfs(N,M,depth+1);\t\t\t\tvisit[i] = false;\t\t\t}\t\t}\t}}MVC1, MVC2, Spring Frame에서 MVC2 패턴  소프트웨어 디자인 패턴 중하나  M(Model) / V(View) / C(Controller)          Model : 내부 비지니스 로직을 처리하기 위한 역할을 할 것입니다. (DB 접근)                  처리되는 알고리즘, DB 와 상호작용(CRUD Create Read Update Delete), 데이터 등등..                    View : 화면에 보여주기 위한 역할을 합니다. 컨트롤러 하위에 종속되어, 모델이나 컨트롤러가 보여주려고 하는 모든 필요한 것들을 보여줄 것입니다.                  최종 사용자에게 화면(UI)으로 보여줌                    Controller : 데이터와 비즈니스 로직 사이의 상호 동작을 관리합니다. 즉, 모델과 뷰를 통제합니다. MVC 패턴에서 View와 Model이 직접적인 상호 소통을 하지 않도록 관리합니다.      MVC 패턴은 크게 MVC 1 패턴과, 스프링이 채택한 MVC 2 패턴으로 나눌 수 있습니다.MVC1MVC1 패턴의 경우 View와 Controller를 모두 JSP가 담당하는 형태를 가집니다.즉 JSP 하나로 유저의 요청을 받고 응답을 처리하므로 구현 난이도는 쉽습니다.단순한 프로젝트에는 괜찮겠지만 내용이 복잡하고 거대해질수록 이 패턴은 힘을 잃습니다.JSP 하나에서 MVC 가 모두 이루어지다보니 재사용성도 매우 떨어지고, 읽기도 힘들어집니다. 즉 유지보수에 있어서 문제가 발생합니다.MVC2MVC2 패턴은 널리 표준으로 사용되는 패턴, 요청을 하나의 컨트롤러(Servlet)가 먼저 받습니다. 즉 MVC1과는 다르게 Controller, View가 분리되어 있습니다. 따라서 역할이 분리되어 MVC1패턴에서의 단점을 보완할 수 있습니다. 그러므로 개발자는 M, V, C 중에서 수정해야 할 부분이 있다면, 그것만 꺼내어 수정하면 됩니다. 따라서 유지보수에 있어서도 큰 이점을 가집니다.Spring FramkeWork에서 MVC2 패턴  요청이 들어오면 DispatcherServlet이 받고 요청내용을 HandlerMapping 에게 보냄  HandlerMapping에서는 가장 적합한 Controller 찾음  Controller 안에 적합한 메서드를 찾아 ModelAndView형식으로 return  ViewResolver는 결과에 해당하는 jsp 리턴 후 클라이언트에게 jsp 응답  http 관계 끊어짐## References.https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AChttps://www.acmicpc.net/problem/15649",
        "url": "/pt-8"
    }
    ,
    
    "pt-5": {
        "title": "21 02 06",
            "author": "jaehong",
            "category": "",
            "content": "주제 : http 0.9 ~ 2.0HTTP 0.9 ~ 2.0HTTP 0.9  요청과 응답이 심플, 확장성이 없음  원 라인 프로토콜이라고도 불림HTTP 1.0  Header가 추가됨(버전, 상태코드, Content-Type Header)  특징 : 1 Connection == 1 Request &amp; 1 Response  문제점 : 요청당 Connection 발생(성능저하, 비용증가)HTTP 1.1      Persistent Connection : 지정한 timeout 동안 Connection을 닫지 않는 방식        Pipelining : 하나의 커넥션에서 응답을 기다리지 않고 순차적인 여러 요청을                   연속적으로 보내 순서에 맞춰 응답 받는 방식 (시간 절감)    문제점     첫번째요청이 처리하는 시간이 오래걸리면 두번째요청부터는 기다려야함  연속된 요청일 경우 중복 Header 전송HTTP 2.0  기존 HTTP/1.X 버전의 성능 향상에 초점  표준의 대체가 아닌 확장HTTP 2.0 특징1. Http 메세지 전송 방식의 변화  바이너리 프레이밍 계층 사용 -&gt; 파싱,전송 속도 증가, 오류 발생 가능성 낮아짐  Stream : 연결된 커넥션 사이에서 바이트의 양방향 흐름. 하나 또는 하나 이상의 message를 전송함  Message : 프레임들의 완성된 배열. Request/Response의 논리적인 배열이라고 보면 된다.  Frame : HTTP/2.0 통신에서 가장 작은 단위의 유닛.각각의 frame 은 헤더를 포함하고 있음. 헤더는 현재 전송되는 프레임이 어디에 포함되는 것인지 알려주는 최소 단위.2. Request &amp; Response Multiplexing  요청과 응답이 다중화가 가능해짐  Frame으로 쪼개짐으로서 메세지간의 순서가 사라짐  1.1에서 Head Of Line Blocking 문제 해결  interleaving(끼워넣기) 방식 또한 제공3. Stream Prioritization  리소스간의 전송 우선순위를 설정  각 스트림에는 1~256 사이의 정수 가중치가 할당될 수 있습니다.  각 스트림에는 다른 스트림에 대한 명시적 종속성이 부여될 수 있습니다.4. Server push  클라이언트가 요청 하지 않은 리소스들을 서버에서 자동 푸쉬5. 헤더 압축(Header Compression)  기존 1.1에서는 header의 중복에 문제가 있었는데 2.0에서 해결  Static dynamic table 도입(중복된 내용은 인덱스만 뽑고, 새로추가된 내용은 허프만 인코딩으로 압축)  헤더의 크기를 줄여 페이지 로드 시간 감소References.https://velog.io/@taesunny/HTTP2HTTP-2.0-%EC%A0%95%EB%A6%AChttps://ijbgo.tistory.com/26https://developer.mozilla.org/ko/docs/Web/HTTPhttps://developers.google.com/web/fundamentals/performance/http2?hl=kohttps://www.youtube.com/watch?v=xcrjamphIp4",
        "url": "/pt-5"
    }
    ,
    
    "pt-4": {
        "title": "21 01 30",
            "author": "jaehong",
            "category": "",
            "content": "주제 : TCP, UDP4계층 Transport Layer  End Point 간의 데이터 전송을 담당하는 계층TCP (Transmission Control Protocol)  신뢰성있는 데이터 통신을 가능하게 해주는 프로토콜TCP 특징  Connection 연결 (3 way-handshake)  흐름제어(Flow Control) : 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지  혼잡제어(Congestion Control) : 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지  오류감지(Error Detection) : 데이터 전달 중 오류 발생시 해당 데이터 재전송세그먼트(Segment)  프로토콜단 에서 데이터가 처리되고 이동하고 하는데 이때 처리되는 단위를 세그먼트  데이터를 전송 받으면 tcp 프로토콜안에서 데이터를 자르고 TCP Header를 추가TCP Header3-way handshake  TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.3-way handshake 과정  [STEP 1]클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 되는 것이다.  [STEP 2]서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다.이때 서버는 SYN_RECEIVED 상태가 된다.  [STEP 3]클라이언트는 서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는것이다. 이때의 B서버 상태가 ESTABLISHED 이다.TCP 데이터 전송 방식4-way handshkae 과정  [STEP 1]클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.  [STEP 2]서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다리는데 이 상태가 TIME_WAIT상태다.  [STEP 3]서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.  [STEP 4]클라이언트는 확인했다는 메시지를 보낸다.TCP 문제점  신뢰성있는 전송은 보장하지만..  매번 Connection 연결 -&gt; 시간적 손실  패킷을 조금만 손실해도 재전송UDP  TCP 보단 신뢰성이 떨어지지만 전송 속도가 빠른 프로토콜UDP 특징  Connectionless(3 way-handshake x)  오류감지(Error Delection)  비교적 데이터의 신뢰성이 중요하지 않을때 사용(ex. 영상 스트리밍)UDP HeaderUDP 데이터 전송 방식정리  TCP와 UDP 모두 Header가 존재  포트 번호를 이용해서 데이터를 전달, 데이터 오류 검사를 위한 Checksum이 존재  TCP는 연결이 성공해야 통신이 가능(연결형 프로토콜), 3-way-handshake  UDP는 연결 없이 통신 가능 (비연결형 프로토콜)  신뢰도를 생각한다면 TCP 속도가 중요하면 UDPReferences.",
        "url": "/pt-4"
    }
    ,
    
    "git-permission-denied": {
        "title": "remote :permission to 에러",
            "author": "jaehong",
            "category": "",
            "content": "    remote: Permission to test01/test01.git denied to xxx.    fatal: unable to access 'https://github.com/test01/test01.git/': The requested URL returned error: 403github 연습용 계정을 만들어서 repo 생성후 push하려는데 위와 같은 에러가 나왔다…찾아보니    A 라는 github 아이디로 '최초' 글로벌 유저 등록을 했고,    나중에 B 라는 아이디로 다시 글로벌 유저등록해서 B 아이디로 push를 진행하려 할 때,    그 push의 시점은 여전히 A 라는 github 아이디를 찾고 있습니다.라고 나와있다.",
        "url": "/git-permission-denied"
    }
    ,
    
    "bean": {
        "title": "빈의 범위",
            "author": "jaehong",
            "category": "",
            "content": "빈(Bean)의 범위싱글톤(SingleTon)  컨테이너에서 생성된 Bean객체의 경우 동일한 타입에서는 한개만생성, 즉 getBean으로 호출시 동일한 객체가 반환프로토타입(ProtoType)  싱글톤 범위와는 다르게 호출 할때마다 새로운 객체생성    &lt;bean id=\"\" class=\"\" scope=\"prototype\"&gt;    &lt;constructor-arg ref=\"injectionBean\"/&gt;    &lt;property name=\"injectionBean\" ref=\"injectionBean\"/&gt;&lt;/bean&gt;      ",
        "url": "/Bean"
    }
    ,
    
    "pt-3": {
        "title": "21 01 23",
            "author": "jaehong",
            "category": "",
            "content": "OSI 7 LayerOSI 7 Layer에 대해  네트워크를 구상할때 참조되는 모델  시스템들이 통신을 하기위해 7단계로 나누었다.1계층 - 물리계층(Physical Layer)  두 대의 컴퓨터가 통신하려면?          모든 프로그램은 0과 1로 구성되어있다.      결국 0 , 1만 주고 받으면된다.        두대의 컴퓨터를 전선 하나로 연결한다고 가정해보자!          1을 보낼떄는 +5V의 전기를      0을 보낼때는 -5V의 전기를      0과 1의 전송이 가능 할 것이다. == 모든 데이터들을 주고받을 수 있다.      그러나 이방법은 실제선 잘 동작 하지 않았습니다.. Why?  다음 그림은 sin 함수입니다.  시간당 전압을 보여준다.  전자기파를 표현하는 함수  이 파동이 진행되는 내내 주파수는 4이다.하지만! 이런파동이라면?  주파수 값이 숫자하나로 고정되지 않는다.  이 전자기파는 파동이 진행되는 동안 주파수 값이 계속변합니다.  위 전자기파의 최소값이 1[Hz], 최대값이 10[Hz]라고 가정  그런데 전선은 모든 주파수를 다 통과 시키지 못한다.!그런데!  앞서 두 대의 컴퓨터 통신을 하려면 0과 1을 주고받을수 있으면 된다라고 했다.  두 대의 컴퓨터가 다음과 같은 전자기파를 주고 받으면 된다. 그런데!  수직과 수평선이 있는 전자기파는 항상 0~무한대[Hz]의 주파수 범위를 가진답니다..  따라서 이런 전기신호를 통과 시킬수 있는 전선이 없습니다.그러면 어떻게 전송해야 할까요?  아날로그 신호로 전송요약 Physical layer  물리매체(전선 등)을 통해 bit 흐름전송  데이터 전송 단위 : 비트(Bit)  프로토콜 : RS-232  장비 : 리피터, 허브2계층 - 데이터 링크 계층(Data-Link Layer)시작하기 전에..여러대의 컴퓨터 간의 통신을 알아보자   철수와 영희는 데이터를 주고 받고 싶어한다.  철수는 영수와도 데이터를 주고 받고 싶어한다.  그러면 … 전선을..몇개 설치해야되냐..  이런 방법은 전선을 꽃을곳과 전선 개수도 많이 필요 -&gt; 비용증가 -&gt; 비효율적그러므로 전선하나로 여러대의 컴퓨터가 통신을 할 방법이 필요!  다음과 같이 전기가 통하는 구리선에 여러대의 컴퓨터가 있다고 가정  구리선은 전자기파가 흐를 수 있으니까 신호는 구리선과 연결된 모든 컴퓨터로 전달!.  그래도 영희에게 데이터가 전달되었으니 데이터 전송은 성공..이제 가운데를 관통하는 전선을 구겨서 상자 안에 넣어보겠습니다.  이렇게 만들면 4대의 컴퓨터가 그대로 통신 할 수 있는 상태이다.  하지만 철수가 영희에게 데이터를 보내려고하면 다른 두 대에 컴퓨터도 그 메세지를 읽을수있다..그런데 상자가 수신자를 확인해서 전달해 줄 수 있으면 어떨까?? 이런 기능을 하도록 만든것이  스위치 입니다..이번에는 새로운 상황을 보겠습니다.  서로 다른 두개의 네트워크가 구축되어있습니다.  이상황에서 철수가 영희에게 데이터를 보내고 싶어합니다.  그런데 전선으로 연결되있지 않아 통신 할 수 가 없습니다.그런데 만약  위 처럼 스위치와 스위치를 연결해서 서로 다른 네트워크에 속한 컴퓨터끼리 통신이 가능하게 해주는 장비를  그리고 이렇게 전세계 컴퓨터들을 연결한 것을 인터넷이라고 합니다.이제 데이터 링크 계층을 본격적으로 보겠습니다.  앞서 두대의 컴퓨터가 0과 1이 된 데이터를 어떻게 주고 받는지 보았습니다. (OSI 1계층)  1계층에 기술만으로 여러대의 컴퓨터가 통신을 하도록 만들 수 없습니다.  이제 여러대의 컴퓨터가 어떻게 통신하는 지 보겠습니다.  네대의 컴퓨터가 스위치 장비를 통해 연결되어있고  영희의 컴퓨터로 세 대의 컴퓨터가 데이터를 거의 동시에 보냈다고 가정해봅시다.  데이터를 어떻게 끊어 읽을까??.. -&gt; 송신자는 데이터 앞 뒤에 특정한 비트열을 붙입니다.  같은 네트워크에 있는 여러 대의 컴퓨터들이 데이터를 주고받기 위해서 필요한 모듈  Framing은 Data-link에 속하는 작업 중 하나입니다.요약 Data Link Layer  데이터링크 계층의 프레임을 받아 전선등  데이터 전송 단위 : 프레임(Frame)  프로토콜 : 이더넷, PPP, ALOHA 등  장비 : 브릿지, 스위치3계층 - 네트워크 계층 (NetWork Layer)  A가 B에게 데이터를 전송하고싶어합니다.  A는 데이터 앞에 목적지 주소 즉B의 주소를 붙이는데  이와 같이 각 컴퓨터들이 갖는 고유한 주소를 IP라고 합니다.요약 NetWork Layer  수많은 네트워크로 연결로 이루어지는 inter-network 속에서  어딘가에 있는 목적지 컴퓨터로 데이터를 전송하기 위해,  Ip 주소를 이용해 길을 찾고(routing)      자신 다음의 라우터에게 데이터를 넘겨주는 것(forwarding)    데이터 전송 단위 : 패킷(packet)  프로토콜 : IP, RIP, ARP, ICMP  장비 : 라우터4계층 - 전송 계층 (Transport Layer)앞에 네트워크 Layer까지 하면서 이제 인터넷상의 모든 컴퓨터가 서로 통신을 할 수 있게 되었습니다.  이 컴퓨터에는 여러개의 프로그램이 실행되어있고  컴퓨터는 세 개의 데이터를 프로세스 들에게 나누어 주려고 합니다.  컴퓨터가 무슨 프로세스에게 데이터를 줄지 어떻게 알수있을까요?  프로세스들은 포트번호를 가져야 합니다.한편 송신자는 데이터를 보낼때 데이터를 받는 수신자 컴퓨터에 있는 프로세스 포트번호를 붙여서 보냅니다.요약 Transport Layer  포트 번호를 사용하여 도착지 컴퓨터의 프로세스에 까지 데이터가 도달하게 하는 모듈  데이터 전송 단위 - TCP 일 때 Segment / UDP 일 때 Datagram  프로토콜 - TCP, UDP  장비 : 게이트 웨이5계층 - 세션 계층(Session Layer)요약 Session Layer  양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공  통신 세션을 구성하며 포트 번호를 기반으로 연결  데이터 전송 단위 : 메시지(message)  프로토콜 - NetBIOS, SSH6계층 - 표현 계층(Presentation layer)  데이터 변환, 암호화, 압축 기능  데이터 전송 단위 : 메시지(message)  프로토콜 - JPG, MPEG, AFP, PAP7계층 - 응용 계층(Application Layer)  사용자에게 서비스 제공  데이터 전송 단위 : 메시지(message)  프로토콜 : HTTP, FTP, DNS, SMTPReferences.우테크 히히님 자료",
        "url": "/pt-3"
    }
    ,
    
    "pt-2": {
        "title": "21 01 16",
            "author": "jaehong",
            "category": "",
            "content": "Collection 구조  Queue를 상속하고 있는 Deque  Queue는 단방향으로 삽입삭제가 가능하다면 Deque은 양방향에서 삽입삭제가 가능Queue/Deque Interface를 구현하는 클래스들  LinkedList  ArrayDeque  Priority QueueLinkedList Class큐의 정의  큐의 사전적의미는 무엇을 기다리는 사람의 줄  FIFO (First In First Out, 선입선출), FCFS (First Come First Service)  한쪽 끝에서는 삽입만 다른 한쪽 끝에서는 삭제만 발생큐 주요 메소드 및 용어            메소드      설명                  Enqueue      큐에 데이터 삽입 하는 메서드              Dequeue      큐에 데이터 삭제 하는 메서드              isEmpty      큐가 empty 상태 인지 확인              isFull      큐가 full 상태 인지 확인              peek      큐의 첫번째 위치에 있는 데이터 추출                  용어      설명                  front, head      삭제가 발생하는 지점을 가르킨다.(포인터로 해석)              rear, tail      삽입이 발생하는 지점을 가르킨다.      배열로 큐 구현public class ArrayQueue  {    // 큐 배열은 front , rear , queue의 size를 가진다.    private int front;    private int rear;    private int queueSize;    private int queueArr[];    // 생성자에서 초기화    public ArrayQueue(int queueSize) {        front = -1;        rear = -1;        this.queueSize = queueSize;    // queue 사이즈 설정        this.queueArr = new int[this.queueSize];// 큐 배열 생성    }    // 큐가 비어있는 상태인지 확인    public boolean isEmpty() {        if(front == rear) {            System.out.println(\"empty\");            return true;        }else{            return  false;        }    }    // 큐가 가득찬 상태인지 확인    public boolean isFull() {        // rear 포인터가 큐의 마지막 인덱스와 동일하면 true 아니면 false        return (rear == this.queueSize-1);    }    // 큐에 데이터 삽입 rear 증가    public void enqueue(int item) {      if(isFull()){          throw new ArrayIndexOutOfBoundsException();      }else {            queueArr[++rear] = item;    // 다음 rear 포인터가 가리키는 위치에 데이터 추가            System.out.println(\"Inserted Item : \" + item);        }    }    // 큐에서 데이터 추출 후 front 증가    public void dequeue() {        if(!isEmpty()) {            ++front;            System.out.println(\"Deleted Item : \" + queueArr[front]);        }    }    // 큐의 첫번째 데이터 추출    public int peek() {        if(!isEmpty()) {            System.out.println(\"Peeked Item : \" + queueArr[front + 1]);        }        return queueArr[front+1];    }    // 큐에 저장된 모든 데이터를 출력    public void printQueue() {        if(!isEmpty()) {            System.out.print(\"Queue elements : \");            for(int i=rear; i&gt;=front+1; i--) {                System.out.print(queueArr[i] + \" \");            }            System.out.println();        }    }    public static void main(String args[]) {        int queueSize = 5;        ArrayQueue arrQueue = new ArrayQueue(queueSize);        arrQueue.isEmpty();        arrQueue.enqueue(1);        arrQueue.enqueue(2);        arrQueue.enqueue(3);        arrQueue.enqueue(4);        arrQueue.enqueue(5);        arrQueue.printQueue();        arrQueue.dequeue();        arrQueue.printQueue();        arrQueue.dequeue();        arrQueue.printQueue();        arrQueue.dequeue();        arrQueue.printQueue();        arrQueue.dequeue();        arrQueue.printQueue();        arrQueue.dequeue();        arrQueue.printQueue();    }}enqueue 그림코드 결과  enqueue 시 rear 1증가  dequeue 시 front 1증가문제점데이터가 다 차있지 않더라도 rear와 front가 계속 증가되다 보면 언젠가는 배열의 사이즈까지 도달하여 더이상 사용할 수 없게 된다는  문제점이 발생한다.       원형, 환형 큐(Circular Queue)  원형큐는 논리적으로 배열의 처음과 끝이 연결 되어있는 것으로 간주한다.  공백상태와 포화 상태를 쉽게 구분하기위해 자리 하나를 항상 비워둔다.  초기 상태에서는 rear, front 값이 0이 된다.우선순위 큐(Priority Queue)      말그대로 ‘우선순위큐’ 우선순위가 가장 높은 데이터를 가장 먼저 삭제 하는 자료구조    구현방법          리스트를 이용하여 구현      힙(heap)을 이용하여 구현        heap의 특징          완전 이진 트리 자료구조      힙에서는 항상 루트 노드(root node)를 제거      최소 힙(min heap)                  루트 노드가 가장 작은 값을 가집니다.          따라서 값이 작은 데이터가 우선적으로 제거                    최대 힙(max heap)                  루트 노드가 가장 큰 값을 가집니다.          따라서 값이 큰 데이터가 우선적으로 제거됩니다.                      완전 이진 트리          root 노드 부터 시작하여, 왼쪽 자식 노드, 오른쪽 자식 노드 순으로 데이터가  차례대로 삽입되는 트리(tree)를 의미합니다.        Min-Heapify()          어떤한 데이터를 힙(heap)에 넣었을 때 힙자료구조가 힙의 성질을 가질때 필요!-Heapify : 일반적으로 힙을 구성하는 함수의 이름을 말한다.-상향식-하양식      Deque 데크  양쪽 큐 끝에서 삽입삭제가 모두 발생 할 수있는 큐  삽입 삭제가 용이, 데이터 중간References.",
        "url": "/pt-2"
    }
    ,
    
    "pt-1": {
        "title": "21 01 09",
            "author": "jaehong",
            "category": "",
            "content": "DI(Dendency Injection)약한 결합과 강한 결합12345678910111213141516171819202122import&nbsp;java.util.Date;&nbsp;public&nbsp;class&nbsp;DI&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;date&nbsp;=&nbsp;new&nbsp;Date();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;getDate(Date&nbsp;d)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;date&nbsp;=&nbsp;d;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;static&nbsp;void&nbsp;User1()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Member&nbsp;m1&nbsp;=&nbsp;new&nbsp;Member();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;static&nbsp;void&nbsp;User2(Member&nbsp;m)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Member&nbsp;m2&nbsp;=&nbsp;m;&nbsp;&nbsp;&nbsp;&nbsp;}}class&nbsp;Member&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;phone;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Member()&nbsp;{}}&nbsp;Colored by Color Scriptercs2.스택(Stack)2-1.스택이란     한 쪽 끝에서만 자료를 넣고 뺄 수 있는 형식의 자료 구조    LIFO2-2 스택 구현다음은 일반적으로 스택에 사용되는 필수적인 메서드 입니다.    push : 스택의 가장 최상위에 데이터를 삽입    pop  : 스택의 가장 최상위에 위치한 데이터를 삭제    Empty : 스텍이 empty 상태인지 확인    clear : 스택에 저장된 모든 데이터를 삭제하고 스택을 초기화    peek : 스택에 가장 최상위에 위치한 데이터를 추출123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public&nbsp;class&nbsp;ArrayStack&nbsp;implements&nbsp;Stack{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;top;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stackSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stackArr[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//생성자에서&nbsp;스택생성&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ArrayStack(int&nbsp;stackSize)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;=&nbsp;-1;&nbsp;//스택&nbsp;포인터&nbsp;초기화&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.stackSize&nbsp;=&nbsp;stackSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackArr&nbsp;=&nbsp;new&nbsp;int[this.stackSize];&nbsp;//stack&nbsp;배열생성&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택이&nbsp;비어있는&nbsp;상태인지&nbsp;확인&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isEmpty()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(top&nbsp;==&nbsp;-1);&nbsp;//&nbsp;스택&nbsp;포인터가&nbsp;-1인경우&nbsp;true&nbsp;반환&nbsp;값이있으면&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택이&nbsp;가득차있는&nbsp;상태인지&nbsp;확인&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isFull()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;top&nbsp;==&nbsp;this.stackSize-1;&nbsp;//스택&nbsp;포인터가&nbsp;마지막인덱스와&nbsp;동일한경우&nbsp;true&nbsp;아닌&nbsp;경우&nbsp;false&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택에&nbsp;데이터&nbsp;추가&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;push(int&nbsp;item)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isFull())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;가득&nbsp;차있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackArr[++top]&nbsp;=&nbsp;item;&nbsp;//다음&nbsp;스택포인터가르키고&nbsp;데이터&nbsp;추가&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Item&nbsp;삽입:&nbsp;\"&nbsp;+&nbsp;item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택의&nbsp;최상위&nbsp;데이터&nbsp;추출&nbsp;후&nbsp;삭제&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;pop()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Item&nbsp;삭제&nbsp;:&nbsp;\"&nbsp;+stackArr[top]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stackArr[top--];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택의&nbsp;최상위&nbsp;데이터&nbsp;추출&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;peek()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Item&nbsp;추출&nbsp;:&nbsp;\"&nbsp;+&nbsp;stackArr[top]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;stackArr[top];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//스택&nbsp;초기화&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;clear()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top&nbsp;=&nbsp;-&nbsp;1;&nbsp;//스택&nbsp;포인터&nbsp;초기화&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stackArr&nbsp;=&nbsp;new&nbsp;int[this.stackSize];&nbsp;//새로운&nbsp;스택&nbsp;생성&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택&nbsp;초기화&nbsp;완료\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;//스택내용&nbsp;모두&nbsp;출력&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;printStack()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isEmpty())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"스택이&nbsp;비어있습니다.\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"Stack&nbsp;list&nbsp;:&nbsp;\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;&nbsp;i&lt;=top;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(stackArr[i]&nbsp;+&nbsp;\"&nbsp;\");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;stackSize&nbsp;=&nbsp;5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayStack&nbsp;arrStack&nbsp;=&nbsp;new&nbsp;ArrayStack(stackSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.push(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.push(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.push(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.pop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.pop();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.peek();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.printStack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arrStack.clear();&nbsp;&nbsp;&nbsp;&nbsp;}}Colored by Color ScriptercsResult2-3 스택의 사용사례    재귀 알고리즘    웹 방문기록(뒤로가기)    후위 표기법 계산    역순 문자열 만들기팩토리얼 구하기 (Factorial)!static int factorial(int n) {    int result = 1;    for(int i= n; i &gt;= 1; i--) {    result *= i;    }    return result;}그리고 이코드를 재귀 함수로 표현해보면 만약 5! 을 구해야된다고 가정을하면factorial(5) = 5 *   4 * 3 * 2 * 1 = 5 * factorial(4);factorial(4) = 4 *   3 * 2 * 1 = 4 * factorial(3);factorial(3) = 3 *   2 * 1 = 3 * factorial(2);factorial(2) = 2 *   1 = 2 * factorial(1);factorial(1) = 1여기서부터는 점화식이 보이기 시작한다. 저 규칙대로하면 factorial(n) = n * factorial(n-1)static int factorial(int n) {    if(n == 1) {  //BaseCase        return 1;    }    return n * factorial(n-1);}2-5 시간복잡도            Insert, Delete        O(1)                Search        O(n)    References.    https://8boknote.tistory.com/67    https://im-developer.tistory.com/121    http://wonwoo.ml/index.php/post/1571",
        "url": "/pt-1"
    }
    ,
    
    "git-error-403": {
        "title": "error 403",
            "author": "jaehong",
            "category": "",
            "content": "Git requested URL returned Error 403 해결방법발생이유2021년 팀 스터디를 시작하기위해 목표설정을 .md파일에 적고    push 하려는데 Git requested URL returned Error 403에러가 나왔다.!두둥..    서칭을 해보니 발생이유는 다양하다고 하나 나의 경우에는 접근 권한을 부여하지 않아 그런거 같았다.!해결방법권한을 부여 받고 아래코드로 깃허브 레퍼지토리에 대한 접근 인증을 받으니 해결됬다.!git remote set-url origin (git 레포 url)    그리고 git 레포 url를 가지고올때 ctrl+c +v 했는데 그럴경우     fatal: protocol 'https' is not supported에러가 발생하였다.    붙여넣기시 그대로 문자열이 출력이되지않았다. 결론은 직접쳐보자!!References.    https://cheonjoosung.github.io/blog/git-push-error",
        "url": "/git-error-403"
    }
    ,
    
    "git-basic": {
        "title": "브랜치(Branch)",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    브랜치(Branch)에 대해 공부해보자!브랜치란??    여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어주는 기능    각자 독립적인 영역(저장소) 안에서 소스코드 변경 가능    각각의 브랜치는 다른 브랜치의 영향을 받지 않음    각각의 브랜치는 다른 브랜치와 병합(Merge)함으로 하나의 브랜치로 모을 수 있다.    메인 브랜치에서 자신의 전용 브랜치 생성 후 작업이 완료되면 메인 브랜치에    자신의 브랜치 변경 사항 적용한다. 이렇게 함으로 독립적으로 작업 수행이 가능하고    그결과들을 하나로 모아 나가게 할 수 있다. 그리고 작업 단위(브랜치가) 남아 있어    문제가 발생했을 때 원인이되는 작업을 찾을 수 있다.master 브랜치저장소를 처음만들면 Git은 'master'라는 이름의 브랜치를 만든다!    새로운 브랜치를 만들어서 다른 브랜치를 선택(Checkout)하지 않는 이상    모든 작업은 'master 브랜치'에서 이루어진다.브랜치 종류통합 브랜치통합 브랜치는 언제든 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치이다.    늘 안정적인 상태로 유지하는 것이 중요하다고 한다.    여기서 안정적인 상태는 모든 기능이 정상적으로 작동하는 것을 말한다.    일반적으로 저장소를 처음생길때 만들어진 'master' 브랜치를 통합 브랜치로 사용한다!토픽 브랜치기능 추가,버그 같은 단위의 작업을 위한 브랜치, 여러개의 토픽 브랜치 생성 가능!    앞서 말했듯 토픽 브랜치 기능이 완성되면 통합 브랜치에 병합하는 방식으로 진행    다른말로 Feature branch라고도 함!References.    https://backlog.com/git-tutorial/kr/",
        "url": "/git-basic"
    }
    ,
    
    "java-collection-framework": {
        "title": "컬렉션 프레임워크(Collection FrameWork)",
            "author": "jaehong",
            "category": "",
            "content": "컬렉션 프레임워크란앞서 배열은 연관되어있는 데이터를 그룹핑해서 관리하기 위한 수단 이라고 배웠었다.    그러나 배열이 가지고 있는 한계(배열의 크기)가 있고 이를 보안한 도구가 컬렉션 프레임워크다.컬렉션 프레임워크 중 하나인 ArrayList를 살펴보자public static void main(String args[]){    String[] arrObj = new String[2];    arrObj[0] = \"one\";    arrObj[1] = \"two\";    arrObj[2] = \"three\"; //컴파일 에러 1.    ArraryList al = new ArraryList();    al.add(\"one\");    al.add(\"two\");    al.add(\"three\");    for(int i =0 ; i&lt;al.size(); i++)){        String value = al.get(i);//컴파일 에러 2.        System.out.println(value);    }}    위에 코드에서 위에는 일반적인 배열이고 밑에는 ArrayList로 작성하였다.    add메서드를 통하여 리스트에 인자로 전달된 객체를 추가하고, get(int index)로 인덱스 위치에 있는 객체를 리턴받는다.    분명 al.add(\"one\")에서 문자열을 추가 시켰다고 생각했다. 그래서 문자열을 담으려고 했고 그러나 컴파일에러가        난이유는 add 메소드는 어떠한 형태의 데이터타입도 수용할 수 있는 형태의 메소드이기 때문에 인자값이 Object여야한다.        왜냐하면 Object는 모든 데이터 타입의 조상? 이기때문이다. 그래서 형변환을 통해 (String)al.get(i) 데이터 타입을 맞춰주어야한다.그러나 (String)al.get(i) 이방식은 옛날 방식이고     타입의 안정성이 떨어진다고 하여    컬렉션 프레임워크에서 제네릭이라는 문법적 수단을 채택    ArraryList&lt;String&gt; al = new ArraryList()&lt;String&gt;;    al.add(\"one\");    al.add(\"two\");    al.add(\"three\");    for(int i =0 ; i&lt;al.size(); i++)){    String value = al.get(i);    System.out.println(value);}인터페이스    인터페이스란 .. 개발코드와 객체가 서로 통신 하는 접점이다.    개발 코드는 객체의 내부구조를 몰라도 인터페이스의 메소드만 알고있으면된다.인터페이스 역할    개발 코드가 객체에 종속되지 않게 하여 객체를 교체 할 수 있도록 함.    개발 코드 변경없이 리턴 값 또는 실행 내용이 다양해 질수있다.(다형성)인터페이스 구성멤버    상수, 추상메소드    Java 8 부터는 default 메소드, 정적 메소드상수 필드 선언    인터페이스는 상수 필드만 선언가능    인터페이스에 선언된 모든 필드는 public static final(상수)의 특징을 가짐     상수명은 대문자    선언과 동시에 초기화 (static 블록을 작성할수없으므로}추상 메소드 선언    인터페이스의 메소드는 기본적으로 실행 블록이 없는 추상 메소드로 선언한다.    public abstract를 생략하더라도 컴파일 과정에서 자동적으로 붙음public interface RemoteControl{int MAX_VOLUME = 10;int MIN_VOLUME =0;public abstract void turnOn();void turnOff();\t//public abstract 생략void setVolume(int volume); //public abstract 생략}디폴트 메소드 선언    자바 8 에서 추가된 인터페이스의 새로운 멤버    [public]이 기본타입으로 default를 붙어야 생성된다.public interface RemoteControl{    default void setMute(boolean mute){    if(mute){        System.out.println(\"무음 처리\");    }else{        System.out.println(\"무음 해제\");    }}정적 메소드 선언public interface RemoteControl{    static void emptyBattery(){        System.out.println(\"배터리가 다 소모 되었습니다.\");    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-collection-framework"
    }
    ,
    
    "spring-di-2": {
        "title": "다양한 의존 주입",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    다양한 의존객체 주입 방법에 대해 알아보자!생성자를 이용한 의존 객체 주입 왼쪽에 있는 자바코드를 .xml파일로 만든것이다.    생성자에 객체를 주입시 constructor-arg 사용하고 ref에 참조대상을 적는다.    즉 객체가 생성될때 studentDao 객체가 주입이된다.setter를 이용한 의존객체 주입    위와 같이 왼쪽의 자바코드를 .xml파일로 만든것이며     만들때 property name 속성값을 적을때에 해당하는 setter 이름에서    set을 때고  앞에글자를 소문자로 setJdbcUrl -&gt; jdbcUrl@Autowired    Spring 지원하는 어노테이션    주입하려고 하는 객체의 타입이 일치하는 객체를 자동으로 주입     구문을 꼭 xml 설정파일에 추가해야한다.    찾는 순서 : 타입 -&gt; 이름 -&gt; @Qualifier -&gt; 실패    멤버변수, 메소드, 생성자 적용가능@Resource    Java에서 지원하는 어노테이션 , 프레임워크에 종속적이지 않다.    기본생성자 무조건 만들어주어야함!    이름 -&gt; 타입 -&gt; @Qualifier -&gt; 실패    @Resource(name=\"\")으로 직접이름지정 할 수있음     구문을 꼭 xml 설정파일에 추가해야한다.    멤버변수, setter 메소드 ||| 생성자는 안됨!@Inject    Java에서 지원하는 어노테이션 , 프레임워크에 종속적이지 않다.    타입 -&gt; @Qualifier-&gt; 이름 -&gt; 실패    Inject를 사용하기 위해서는 maven or gradle에 javax 라이브러리 의존성 추가    java파일에서 @Inject @Named(value=\"id값\")으로 bean객체 지정가능    멤버변수, 메소드, 생성자@Qulifier    동일한 객체가 여러개 있을시    Autowired 사용하면 자동 주입 대상 객체를 판단하지 못해 Exception 발생    그래서 .xml bean태그안에 Qualifier태그로 value 값 명시 후      Autowired밑에 @Qualifier(\"value값\")지정&lt;/li&lt;/ul&gt;References.    ",
        "url": "/spring-di-2"
    }
    ,
    
    "spring-di": {
        "title": "DI(Dependency Injection)",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    DI(Dependency Injection) 알기Spring 프레임워크    프레임 워크는 마치 네이게이션과 같다.    길 탐색은 네비가 하고 안내를 들은 사용자는 운전만 하면됨Spring 에서 제공하는 모듈    spring-core : DI, IoC 제공    aop : AOP 구현 기능 제공    jdbc : DB를 쉽게 다룰 수 있는 기능 제공    tx : 트랜젝션 관련 기능제공    webmvc : MVC구현 기능 제공    그리고 이러한 모듈을 사용하려면 .xml 파일등에 명시하면 자동으로 라이브러리를 다운받는다.스프링 컨테이너(IoC)스프링에서 객체를 생성,조립하는 컨테이너로,   컨테이너를 통해 생성된 객체를 빈(Bean)이라고 부른다.스프링 파일 구조    스프링 프로젝트 Root                    src                                    main                                                    java : .java파일 관리                            resources : 자원관리 폴더 .xml or property file                                                    pom.xml : 각각의 스프링프로젝트는 pom.xml 파일을 가지고있고 외부 repository에 있는 필요한 library를                내가 개발중인 프로젝트에 쉽게 다운로드 할 수 있게 도와주는 파일이다.        .xml 파일에서 객체 생성&lt;bean id = \"id값\" class=\"패키지명.클래스파일명\"/&gt;    Java에서는 new 키워드를 사용해서 객체를 생성했다.    Spring에서는 bean 태그 위에서 자동으로 객체가 생성이 되며    객체가 생성됬다는건 메모리에 로드가 됬다는 이야기이고    스프링에서는 메모리가 로드 된 곳을 스프링컨테이너라고 한다.    bean을 생성했으니 이제 java파일에서 객체를 실행시키려면    1. .xml파일(컨테이너)를 생성    GenericXmlApplicationContext 데이터 타입선언 후 객체생성 및 매개변수로는 .xml경로를 설정하면된다.    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:apllicationContext.xml\");    2.컨테이너 안에있는 Bean 객체를 가져다가 쓴다.(객체생성은 컨테이너가 알아서 한다.)    클래스명 변수명 = ctx.getBean(\"빈아이디\", 클래스명.class);    ex) TranspotationWalk trans = ctx.geBean(\"tWalk\", TranspotationWalk.class);    ctx.close //자바에서는 외부리소스 사용후 반환 해주어야한다.References.    ",
        "url": "/spring-di"
    }
    ,
    
    "spring-introduce": {
        "title": "스프링 개요",
            "author": "jaehong",
            "category": "",
            "content": "공부 목표    Spring 개요    Spring 모듈    Spring 컨테이너(IOC)Spring 프레임워크    프레임 워크는 마치 네이게이션과 같다.    길 탐색은 네비가 하고 안내를 들은 사용자는 운전만 하면됨Spring 에서 제공하는 모듈    spring-core : DI, IoC 제공    aop : AOP 구현 기능 제공    jdbc : DB를 쉽게 다룰 수 있는 기능 제공    tx : 트랜젝션 관련 기능제공    webmvc : MVC구현 기능 제공    그리고 이러한 모듈을 사용하려면 .xml 파일등에 명시하면 자동으로 라이브러리를 다운받는다.스프링 컨테이너(IoC)스프링에서 객체를 생성,조립하는 컨테이너로,   컨테이너를 통해 생성된 객체를 빈(Bean)이라고 부른다.스프링 파일 구조    스프링 프로젝트 Root                    src                                    main                                                    java : .java파일 관리                            resources : 자원관리 폴더 .xml or property file                                                    pom.xml : 각각의 스프링프로젝트는 pom.xml 파일을 가지고있고 외부 repository에 있는 필요한 library를                내가 개발중인 프로젝트에 쉽게 다운로드 할 수 있게 도와주는 파일이다.        .xml 파일에서 객체 생성&lt;bean id = \"id값\" class=\"패키지명.클래스파일명\"/&gt;    Java에서는 new 키워드를 사용해서 객체를 생성했다.    Spring에서는 bean 태그 위에서 자동으로 객체가 생성이 되며    객체가 생성됬다는건 메모리에 로드가 됬다는 이야기이고    스프링에서는 메모리가 로드 된 곳을 스프링컨테이너라고 한다.    bean을 생성했으니 이제 java파일에서 객체를 실행시키려면    1. .xml파일(컨테이너)를 생성    GenericXmlApplicationContext 데이터 타입선언 후 객체생성 및 매개변수로는 .xml경로를 설정하면된다.    GenericXmlApplicationContext ctx = new GenericXmlApplicationContext(\"classpath:apllicationContext.xml\");    2.컨테이너 안에있는 Bean 객체를 가져다가 쓴다.(객체생성은 컨테이너가 알아서 한다.)    클래스명 변수명 = ctx.getBean(\"빈아이디\", 클래스명.class);    ex) TranspotationWalk trans = ctx.geBean(\"tWalk\", TranspotationWalk.class);    ctx.close //자바에서는 외부리소스 사용후 반환 해주어야한다.References.    https://www.inflearn.com/",
        "url": "/spring-introduce"
    }
    ,
    
    "jsp-board-crud": {
        "title": "게시판 CRUD",
            "author": "jaehong",
            "category": "",
            "content": "게시판 CRUDjsp를 마무리 하면서 전체적인 기능들을 살펴보았다.전체적인 컴포넌트 설계    모든 요청은 일단 Controller로 간다.    Controller단 에서 DB에 대한 접근이 필요하다면 Command로 간다.    Command 단에서는 Dao에 대한 접근과 필요하다면 화면에 DB에 대한 정보를 JSP로 넘기기위해 request.setAttribute 사용이제 전체적인 코드를 살펴보자.BFrontController.java@WebServlet(\"*.do\")    Servelt mapping을 하기위해 선언되었다.    mapping을 하는 이유는 보안 때문이다.         기존경로가 http://localhost:8080/프로젝트명/servlet/패키지명.클래스명 이라고 자세히 정보를 나타내게되면 보안상으로 취약하다고한다.    그래서 http://localhost:8080/프로젝트명/URL명 으로 간단하게 변경 하는 것이다.     .jsp는 localhost:8080/프로젝트명/파일명.jsp 치면 나오지만        .java 파일은 그렇지 않다.        (매핑 없이 실행해보면 그 경로의 파일을 찾지 못한다고 오류가 난다. )        그래서 실행할 수 있도록 매핑을 하는 것이고,        그 매핑을 함으로써 .jsp에서 매핑된 이름으로 .java 파일에 요청을 보낼 수 있다고 한다.    또한 mapping방법은 @(어노테이션 뿐만아니라) WebContent폴더 안에 web.xml 파일을 이용해 등록하는 방법도 있다.public class BFrontController extends HttpServlet {    private static final long serialVersionUID = 1L;    public BFrontController() {        super();    }    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {        actionDo(request,response);    }    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    actionDo(request,response);}    HttpServlet을 상속받는 클래스는 doGet, doPost 메소드를 오버라이딩할 수 있기에 이 클래스는 서블릿으로 동작할 수 있다.    그리고 doGet, doPost 메서드는 모두 HttpServletRequest와 HttpServletResponse 객체를 매개변수로 가지고 있다.    이 두 객체는 서블릿과 클라이언트 사이를 연결해주는 중요한 객체들이다.private void actionDo(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    request.setCharacterEncoding(\"UTF-8\");    String viewPage = null; //최종적으로 페이지가 호출될것인지    BCommand command =null;//model객체로 부터 로직을수행하기위함    String uri = request.getRequestURI();    String conPath = request.getContextPath();    String com = uri.substring(conPath.length());    if(com.equals(\"/write_view.do\")) {        viewPage = \"write_view.jsp\";    }else if(com.equals(\"/write.do\")) {        command = new BWriteCommand();        command.execute(request,response);        viewPage = \"list.do\";    }else if(com.equals(\"/list.do\")) {        command = new BListCommand();        command.execute(request,response);        viewPage = \"list.jsp\";    }else if(com.equals(\"/content_view.do\")) {        command = new BContentCommand();        command.execute(request,response);        viewPage = \"content_view.jsp\";    }else if(com.equals(\"/modify.do\")) {        command = new BModifyCommand();        command.execute(request,response);        viewPage = \"list.do\";    }else if(com.equals(\"/delete.do\")) {        command = new BDeleteCommand();        command.execute(request,response);        viewPage = \"list.do\";    }else if(com.equals(\"/reply_view.do\")) {        command = new BReplyViewCommand();        command.execute(request,response);        viewPage = \"reply_view.jsp\";    }else if(com.equals(\"/reply.do\")) {        command = new BReplyCommand();        command.execute(request,response);        viewPage = \"list.do\";    }    RequestDispatcher dispatcher = request.getRequestDispatcher(viewPage);    dispatcher.forward(request, response);}    actionDo 메서드는 요청에 맞는 Command로 보내는 역할을 한다.    request.getRequestURI()에는 /패키지명/매핑명 을 가지고있고    request.getContextPath()에는 /패키지명 있기에    uri.substring(conPath.length())는 결국 /매핑명만 가지게 된다.    이렇게 매핑명만 분리해서 문자열 비교로 해당 요청에맞는 command로 넘겨주게 된다.    RequestDispatcher는 앞서 command에서 가공된 DB값들을 가지고 View단으로 넘겨주는 역할을 한다.BCommand.javapublic interface BCommand {    void execute(HttpServletRequest request, HttpServletResponse response);}    해당 기능을 강제로 구현함과 메서드명을 통일함으로 interface 사용    모든 Command는 BCommand를 상속 한다.    request, response 객체를 사용하기 위함BWriteCommand.javapublic class BWriteCommand implements BCommand{    @Override    public void execute(HttpServletRequest request, HttpServletResponse response) {        // TODO Auto-generated method stub        String bName = request.getParameter(\"bName\");        String bTitle = request.getParameter(\"bTitle\");        String bContent = request.getParameter(\"bContent\");        BDao dao = new BDao();        dao.write( bName, bTitle, bContent);    }}BListCommand.javapublic class BListCommand implements BCommand {    @Override    public void execute(HttpServletRequest request, HttpServletResponse response) {        // TODO Auto-generated method stub        BDao dao = new BDao();        ArrayList&lt;BDto&gt; dtos = dao.list();        request.setAttribute(\"list\", dtos);    }}BContentCommand.javapublic class BContentCommand implements BCommand {@Overridepublic void execute(HttpServletRequest request, HttpServletResponse response) {    // TODO Auto-generated method stub    String bId = request.getParameter(\"bId\");    BDao dao = new BDao();    BDto dto = dao.contentView(bId);    request.setAttribute(\"content_view\", dto);    }}    Main화면에서 여러개의 글 목록중 특정 글에대한 정보를 출력하기 위한 클래스    .jsp 단에서 value에 저장된값을 dao로 넘겨줌BModifyCommand.javapublic class BModifyCommand implements BCommand {    @Override    public void execute(HttpServletRequest request, HttpServletResponse response) {        // TODO Auto-generated method stub        String bId\t= request.getParameter(\"bId\");        String bName = request.getParameter(\"bName\");        String bTitle = request.getParameter(\"bTitle\");        String bContent = request.getParameter(\"bContent\");        BDao dao = new BDao();        dao.modify(bId, bName, bTitle, bContent);    }}BDeleteCommand.javapublic class BDeleteCommand implements BCommand {@Overridepublic void execute(HttpServletRequest request, HttpServletResponse response) {    // TODO Auto-generated method stub    String bId\t= request.getParameter(\"bId\");    BDao dao = new BDao();    dao.delete(bId);    }}    순서대로 C, R(글 전체출력,세부정보출력), U, D    Read 같은경우는 Dao를 통해 가져온 값들을 화면상에 출력해주어야하기에 request.setAttribute에 값을 담아서 보냄    Create Update는 화면단에서 입력된 값들을 DB상에 저장하기위해 request.getAttribute로 값을 받아서 Dao로 보냄    Update,Delete, Read(세부정보출력)시 특정 글의 id값을 가져와서 Dao로 보냄BDao.java    DataSource dataSource;    public BDao() {        try {            Context context = new InitialContext();            dataSource = (DataSource) context.lookup(\"java:comp/env/jdbc/Oracle11g\");            }catch(Exception e) {                e.printStackTrace();        }    }    DBCP를 사용하기위해 Tomcat context.xml에 설정한 DB 정보들 java코드로 연결하기 위해        JNDI(Java Naming and Directory Interface) 자바 네이밍 API를 사용한다. 네이밍 패키지의 클래스를        가지고 이름으로 객체를 획득하는 것을 말한다.        쉽게말해 이름을 이용해서 원하는 정보 혹은 자원(Connection)을 찾을 수 있는 서비스    public void write(String bName, String bTitle, String bContent) {    Connection connection = null;    PreparedStatement psmt = null;    try {        connection = dataSource.getConnection();        String query = \"insert into mvc_board (bId, bName, bTitle, \"        + \"bContent, bHit, bGroup, bStep, bIndent)\"        + \"values (mvc_board_seq.nextval, ?, ?, ?, 0, mvc_board_seq.currval, 0, 0)\";        psmt = connection.prepareStatement(query);        psmt.setString(1, bName);        psmt.setString(2, bTitle);        psmt.setString(3, bContent);        int rn = psmt.executeUpdate(); //정상적으로 insert시 1반환    }catch (Exception e) {        // TODO: handle exception        e.printStackTrace();    }finally {        try {            if(psmt != null)psmt.close();            if(connection != null) connection.close();        }catch (Exception e2) {            e2.printStackTrace();       }    }}    SQL문장을 실행시키기 위해 Connection 객체에 위에서 생성한 db정보를 넘겨준다.    문자열로 쿼리를 작성하는데 ?자리는 매개변수로 받아온 값들이 들어갈수있도록 setString 메서드로 처리한다.        setString(정수(물음표 자리), 값)        executeUpdate로 정상적으로 쿼리가 실행되었다면 정수값 1을 리턴한다.    catch에서는 예외처리    finally에서는 메모리 해제 &amp; 예외처리를 한다.    Update와 Delete도 이와 비슷한 구조로 처리가 되어 따로 기록하진않았다.public ArrayList&lt;BDto&gt; list(){    ArrayList&lt;BDto&gt; dtos = new ArrayList&lt;BDto&gt;();    Connection connection = null;    PreparedStatement psmt = null;    ResultSet rs = null;    try {        connection = dataSource.getConnection();        String query = \"select bId, bName, bTitle, bContent, bDate, bHit, bGroup, bStep, bIndent \"        +\"from mvc_board \"        +\"order by bGroup desc, bStep asc\";        psmt = connection.prepareStatement(query);        rs = psmt.executeQuery();        while(rs.next()) {            int bId = rs.getInt(\"bId\");            String bName = rs.getString(\"bName\");            String bTitle = rs.getString(\"bTitle\");            String bContent = rs.getString(\"bContent\");            Timestamp bDate = rs.getTimestamp(\"bDate\");            int bHit = rs.getInt(\"bHit\");            int bGroup = rs.getInt(\"bGroup\");            int bStep = rs.getInt(\"bStep\");            int bIndent = rs.getInt(\"bIndent\");            BDto dto = new BDto( bId,  bName,  bTitle,  bContent,  bDate,  bHit,  bGroup,  bStep,  bIndent );            dtos.add(dto);            }    }catch (Exception e) {        e.printStackTrace();    }finally {        try {            if(rs != null) rs.close();            if(psmt != null) psmt.close();            if(connection != null) connection.close();        }catch(Exception e2) {            e2.printStackTrace();        }    }        return dtos;    }    글 목록을 출력하는 Dao 부분이다.    ResultSet은 Select의 결과 값을 저장하는 객체이고, 데이터타입은 dto이며,        ArrayList를 사용, 각각의 글에대한 정보들을 담아 ReturnType으로 넘겨 준다.References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/    https://gmlwjd9405.github.io/2018/10/28/servlet.html    http://blog.naver.com/PostView.nhn?blogId=smilennv&amp;logNo=220454626217    RequestDispatcher와 sendRedirect 알기",
        "url": "/jsp-board-crud"
    }
    ,
    
    "beakjoon-10809": {
        "title": "알파벳 찾기",
            "author": "jaehong",
            "category": "",
            "content": "문제알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오.입력첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.출력각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, … z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다.예제입력1baekjoon예제 출력1 0 -1 -1 2 -1 -1 -1 -1 4 3 -1 -1 7 5 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1문제생각a~z까지 입력값에 있으면 입력값에 대한 위치를 출력0부터 시작, 입력한 문자중 없으면 -1중복된 2번째 문자부터는 무시codeimport java.io.*;public class Main {    public static void main(String args[]) throws IOException{        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String s = br.readLine();        for(char c='a';c&lt;='z';c++) { //a~z까지            System.out.print(s.indexOf(c)+\" \");            // indexOf() :  특정 문자나 문자열이 앞에서부터 처음 발견되는 인덱스를 반환하며            //                  찾지 못하면 -1을 반환한다..        }    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/10809&gt;",
        "url": "/beakjoon-10809"
    }
    ,
    
    "jsp-mvc": {
        "title": "MVC 패턴",
            "author": "jaehong",
            "category": "",
            "content": "MVC    Model, View, Controller 약자    각각의 기능들이 상호작용mvc model1View + Controller = .jspmvc model2모두 모듈화 되어있는 형태References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-mvc"
    }
    ,
    
    "jsp-uri-pattern": {
        "title": "uri-pattern",
            "author": "jaehong",
            "category": "",
            "content": "디렉터리 패턴서블릿을 만들면 .xml or annotation을 이용해서 mapping 하는 방식을 공부했었는데디렉터리 형태로 서버의 해당 컴포넌트(서블릿)을 찾아서 실행하는 구조를 디렉터리 패턴이라고 한다.확장자 패턴확장자 형태로 서버의 해당 컴포넌트를 찾아서 실행하는 구조확장자 패턴은 두가지가있다.    FrontController 패턴    Command 패턴FrontControllerCommandReferences.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-uri-pattern"
    }
    ,
    
    "jsp-jstl": {
        "title": "JSTL",
            "author": "jaehong",
            "category": "",
            "content": "개요JSP 경우 HTML 태그와 같이 사용하므로 코드 가독성이 떨어진다.이런 단점을 보완하고자 태그 라이브러리인 JSTL 등장!Tomcat 컨테이너에 포함 되어있지 않아 별도 설치필요하다.나의 경우 링크 여기를 통해서jakarta-taglibs-standard-1.1.2.zip을 다운하였다.JSTL 라이브러리JSTL에서는 5가지 라이브러리 제공    Core    XML Processing    I18N formatting    SQL    FunctionsCore기본적인 라이브러리로 출력,제어,반복문 기능들이 포함페이지 지시자를 사용한 페이지 속성선언&lt;%@ taglib uri = http://java.sun.com/jsp/jstl/core prefix=”c” %&gt; 보통 앞글자로 prefix정함출력 태그    &lt;c:out value=\"출력값\" default=\"기본값\" escapeXml=\"true or false\"/&gt;변수 설정 태그    &lt;c:set var=\"변수명\" value=\"설정값\" target=\"객체\" property=\"값\" scope=\"범위\"/&gt;변수 제거 태그    &lt;c:remove var=\"변수명\" scope=\"범위\"/&gt;예외 처리 태그    &lt;c:catch var=\"변수명\"/&gt;제어문(if)    &lt;c:if test=\"조건\" var=\"조건 처리 변수명\" scope=\"범위\"/&gt;제어문(switch)    &lt;c:choose&gt;        &lt;c:when test=\"조건\"&gt;처리내용&lt;/c:when&gt;        &lt;c:oherwise&gt;처리 내용&lt;/c:oherwise&gt;    &lt;/c:choose&gt;반복문(for)문    &lt;c:forEach itmes=\"객체명\" begin=\"시작 인덱스\" end=\"끝 인덱스\" step=\"증감식\"               var=\"변수명\" varStatus=\"상태변수\"/&gt;페이지 이동 태그    &lt;c:redirect url =\"url\"/&gt;파라미터 전달 태그    &lt;c:param name=\"파라미터명\" value=\"값\"/&gt;예제&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri =\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;c:set var=\"varName\" value=\"varValue\"/&gt;varName : &lt;c:out value = \"${varName }\"/&gt;&lt;br/&gt;&lt;c:remove var = \"varName\"/&gt;varName : &lt;c:out value =\"${varName }\"/&gt;&lt;hr/&gt;&lt;c:catch var =\"error\"&gt;    &lt;%=2/0 %&gt;&lt;/c:catch&gt;&lt;br/&gt;&lt;c:out value=\"${error}\"/&gt;&lt;hr/&gt;&lt;c:if test=\"${1+2==3}\"&gt;    1 + 2 = 3&lt;/c:if&gt;&lt;c:if test=\"${1+2!=3}\"&gt;    1 + 2 != 3&lt;/c:if&gt;&lt;hr/&gt;&lt;c:forEach var=\"fEach\" begin=\"0\" end=\"30\" step=\"3\"&gt;    ${fEach}&lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-jstl"
    }
    ,
    
    "jsp-el-html": {
        "title": "EL(Expression Language)",
            "author": "jaehong",
            "category": "",
            "content": "Expression Language    표현식 또는 액션 태그를 대신해서 값을 표현하는 언어    코드의 간결화를 위해 사용표현식${1+2}&lt;br/&gt;${1-2}&lt;br/&gt;${(1&gt;2) ? 1 : 2 }&lt;br/&gt;&lt;br/&gt;&lt;%= 1+2 %&gt;&lt;br/&gt;&lt;%= 1-2 %&gt;&lt;br/&gt;&lt;%= (1&gt;2) ? 1 : 2 %&gt;======================================================태그이름 :   &lt;jsp:getProperty name=\"member\" property=\"name\" /&gt;아이디 : &lt;jsp:getProperty name=\"member\" property=\"id\" /&gt;비번:   &lt;jsp:getProperty name=\"member\" property=\"pw\" /&gt;&lt;br/&gt;이름 :   ${member.name }아이디 : ${member.id }비번:   ${member.pw }내장객체    pageScope : page 객체를 참조하는 객체    requestScope : request 객체를 참조하는 객체    sessionScope : session 객체를 참조하는 객체    applicationScope : application 객체를 참조하는 객체    param : 요청 파라미터를 참조하는 객체    paramValues : 요청 파라미터(배열)을 참조하는 객체    initParam 초기화 파라미터를 참조하는 객체    cookie : cookie 객체를 참조하는 객체예제1입력 폼&lt;form action=\"objelOk.jsp\"&gt;    아이디 : &lt;input type=\"text\" name =\"id\"&gt;    비밀번호 : &lt;input type=\"password\" name =\"pw\"&gt;    &lt;input type=\"submit\" value=\"login\"&gt;&lt;/form&gt;출력 폼&lt;%String id = request.getParameter(\"id\");String pw = request.getParameter(\"pw\");%&gt;아이디 &lt;%= id %&gt;&lt;br/&gt;비번 &lt;%= pw %&gt;&lt;hr/&gt;&lt;!-- 내장객체 param사용 --&gt;아이디 ${param.id }&lt;br/&gt; &lt;!-- request.getParameter(\"id\");과 동일 --&gt;비밀번호 ${param.pw }&lt;br/&gt;아이디 ${param[\"id\"]}&lt;br/&gt; &lt;!-- request.getParameter(\"id\");과 동일 --&gt;비밀번호 ${param[\"pw\"]}&lt;br/&gt;=======================&lt;!--내장 객체--&gt;applicationScope : ${applicationScope.application_name }&lt;br/&gt;sessionScope : ${sessionScope.session_name }&lt;br/&gt;pageScope : ${pageScope.page_name }&lt;br/&gt;requestScope : ${requestScope.request_name }예제2&lt;!-- web.xml파일에서 context-param에 등록된 데이터를 들고 올때--&gt;&lt;!-- 8-2에서 배운 ServletContext --&gt;&lt;%  String id = getServletContext().getInitParameter(\"con_name\");    String pw = getServletContext().getInitParameter(\"con_id\");    String path = getServletContext().getInitParameter(\"con_pw\");%&gt;&lt;%= id %&gt;&lt;br/&gt;&lt;%= pw %&gt;&lt;br/&gt;&lt;%= path %&gt;&lt;br/&gt;============================&lt;!-- EL을 사용해서 가지고올때 --&gt;${initParam.con_name }&lt;br/&gt;${initParam.con_id }&lt;br/&gt;${initParam.con_pw }&lt;br/&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-el.html"
    }
    ,
    
    "jsp-file-upload-html": {
        "title": "file upload",
            "author": "jaehong",
            "category": "",
            "content": "fileForm.jsp&lt;form action = \"fileFormOk.jsp\" method=\"post\" enctype=\"multipart/form-data\"&gt;    파일 : &lt;input type=\"file\" name=\"file\"&gt;&lt;br/&gt;    &lt;input type=\"submit\" value=\"File Upload\"&gt;&lt;/form&gt;    &lt;input type=\"file\"&gt; : 파일을 선택할 수 있는 창을 만든다.    &lt;form method=\"post\"&gt; : 형태로 전송한 폼에 담겨진 파라미터들은 request 객체를 통해 이름에 해당되는 값을 얻어낼 수 있다 .    하지만 enctype=\"multipart/form-data\"로 지정한 폼은 request객체로 파라미터의 값을 얻어낼 수 없다.multipart/form-data 전송한 양식의 파라미터들에 대한 값을 얻어내기 위해특별한 컴포넌트가 필요하다!http://www.servlets.com/cos/여기서 cos 파일을 다운 받아 cos/lib/cos.jar 파일을 WebContent/WEB-INF/lib에 복사한다.fileFormOk.jsp실질적인 업로드가 진행되는 jsp 파일&lt;%@page import=\"java.util.Enumeration\"%&gt;&lt;%@page import=\"com.oreilly.servlet.MultipartRequest\"%&gt;&lt;%@page import=\"com.oreilly.servlet.multipart.DefaultFileRenamePolicy\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"pageEncoding=\"UTF-8\"%&gt;&lt;%    String path  = request.getRealPath(\"fileFolder\"); //파일이 실제로 저장되는 폴더명    int size = 1024 * 1024 * 10; //10M    String file=\"\";    String oriFile = \"\";    try{        //MultipartRequest객체가 파일 업로드를 담당        //form에서 가져온 인자값을 얻기위해        //업로드될 위치        //업로드 최대크기 설정 초과할경우 exception        //한글        //이름이 같은 파일을 업로드할경우 파일이름 변환        MultipartRequest multi =  new MultipartRequest(request, path, size, \"utf-8\", new DefaultFileRenamePolicy());        Enumeration files = multi.getFileNames(); //올린파일이름들을 얻는다.        String str = (String)files.nextElement();//파일이름 저장        file = multi.getFilesystemName(str); //파일이름이 중복되어있을때 처리        oriFile = multi.getOriginalFileName(str);    }catch(Exception e){        e.printStackTrace();    }%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;file upload success;&lt;/body&gt;&lt;/html&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-file-upload.html"
    }
    ,
    
    "jsp-member-crud-html": {
        "title": "회원 CRUD",
            "author": "jaehong",
            "category": "",
            "content": "흐름도MemberDao.javalogin.jsploginOk.jspjoin.jspjoinOk.jspmain.jspmodify.jspmodifyOk.jsplogout.jspmember.jsReferences.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-member-crud.html"
    }
    ,
    
    "beakjoon-1065": {
        "title": "한수",
            "author": "jaehong",
            "category": "",
            "content": "한수문제어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다.N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.입력110출력99import java.io.*;public class Main {public static void main(String args[]) throws IOException {    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    int n = Integer.parseInt(br.readLine());    bw.write(check(n) + \"\\n\");    bw.flush();    br.close();    bw.close();    }    static int check(int n) {        int count =0; //정해진입력값에서 한수가 몇개인지        int a[] = new int[3]; //100~ 999자리수를 저장하기위한 배열        for(int i=1; i&lt;=n; i++) {//  1~ 입력만큼            if(i &lt; 100 ) count = i; //1~99는 모두 한수            else if(i == 1000) break; //1000은 한수가 아님            else {                int k = 0, t = i;                while (t &gt; 0) { //일의자리수를 배열에 넣기위한 로직                a[k] = t % 10;                t /= 10;                k++;            }            if (a[0] - a[1] == a[1] - a[2]) //공차가 같으면 한수            count++;        }    }        return count;    }}처음에는 문제 이해를 못하였는데 입력값으로 주어진 수 만큼 예를 들어 110이면 1~110만큼 수 중에    한수 즉 123 같이 각 자리의 수만봤을때 1 2 3 이 1씩증가되있으므로 등차수열에 성립이 된다하여    123은 한수에 포함이 된다.문제출처    백준알고리즘 https://www.acmicpc.net/problem/1065&gt;",
        "url": "/beakjoon-1065"
    }
    ,
    
    "jsp-dbcp-html": {
        "title": "dbcp",
            "author": "jaehong",
            "category": "",
            "content": "커넥션 풀DAO, DTODAO: Data Access Object -&gt; DB로 접근해서 로직수행DTO: Data Transfer Object -&gt; DAO를 이용하여 일반적인 변수에 데이터를 할당하여 사용할수도있지만. 그럴경우 코드가 지저분해진다.                                그래서 데이터만을 모아둔 클래스를 별도로 정의한것을 DTOPreparedStatementsql문 실행을 위해 Statement 객체를 이용했는데, 중복코드가 많아진다는 단점이있어   단점 보안을 위해 PreparedStatement 등장커넥션 풀(DBCP)    DB 부하를 막기위해 Connection 객체를 미리 생성하여 사용    tomcat 컨테이너 안 context.xml 파일에 코드 추가context.xml&lt;Resource        auth=\"Container\"        driverClassName = \"oracle.jdbc.driver.OracleDriver\"        url = \"jdbc:oracle:thin:@localhost:1521:orcl\"        username = \"scott\"        password = \"1234\"        name = \"jdbc/Oracle11g\"        type = \"javax.sql.DataSource\"        maxActive = \"50\"        maxWait = \"1000\"/&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-dbcp.html"
    }
    ,
    
    "restapi-html": {
        "title": "Rest API란 무엇인가..",
            "author": "jaehong",
            "category": "",
            "content": "rest api란 무엇인가.References.    https://www.hanbit.co.kr/",
        "url": "/restapi.html"
    }
    ,
    
    "beakjoon-4673": {
        "title": "셀프 넘버",
            "author": "jaehong",
            "category": "",
            "content": "셀프넘버public class Main {    public static void main(String[] args){        int[] check = new int[10001];        for (int i = 0; i&lt;10001;++i) {            int n = sum(i); //            if (n&lt;10001 &amp;&amp; check[n]==0) {                check[n]=1;            }        }        StringBuilder a = new StringBuilder();        for (int i =0; i&lt;10001; ++i) {            if(check[i]==0) {            a.append(i).append('\\n');            }        }        System.out.println(a);}    public static int sum(int number) {        int sum = number;        while (number!=0) {            sum += number%10;            number/=number/10;        }        return sum;    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/4673&gt;",
        "url": "/beakjoon-4673"
    }
    ,
    
    "beakjoon-4344": {
        "title": "평균은 넘겠지",
            "author": "jaehong",
            "category": "",
            "content": "평균은 넘겠지import java.io.*;import java.util.StringTokenizer;/* 1. 테스트 케이스 개수 입력* 2. 학생수와 점수 입력* 3. 첫번째 입력한값이 학생수 저장* 4. 각테스트 케이스마다 합과 평균이상인 학생이 다르므로 초기화* 5. 배열에 점수저장 및 점수합, 평균값 계산* 6. 각 점수와 평균을 비교해서 평균이 넘으면 count;* 7. 평균을 넘은사람/총인원 *100 &amp; 소수점 3째자리 반올림해서 출력.*/public class Main{    public static void main(String args[]) throws IOException{        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));        StringTokenizer st;        //1        int c = Integer.parseInt(br.readLine());        for(int i=0; i&lt;c; i++) {            //2            st = new StringTokenizer(br.readLine());            //3            int studentN = Integer.parseInt(st.nextToken());            int[] arr = new int[studentN];            //4            int count =0;            int sum=0;            //5            for(int j=0; j&lt;studentN; j++) {                arr[j] = Integer.parseInt(st.nextToken());                sum += arr[j];            }            double avg = (double)(sum/studentN);            //6            for(int value : arr) {                if(value &gt; avg) {                    count++;                }            }            //7            String result = String.format(\"%.3f\", (((double)count/studentN)*100))+\"%\";            bw.write(result + \"\\n\");        }        bw.flush();        br.close();        bw.close();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/4344&gt;",
        "url": "/beakjoon-4344"
    }
    ,
    
    "beakjoon-8958": {
        "title": "OX퀴즈",
            "author": "jaehong",
            "category": "",
            "content": "OX 퀴즈import java.io.*;import java.util.*;public class Main{    public static void main(String args[]) throws IOException {        //1. List를 사용해서 동적배열로 입력받기        //2. 저장된 문자열을 split로 문자로 구분후 문자열배열에 저장        //3.O가 연속될때마다 값이 1증감되고 X를 만나면 다시 0에서 시작        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));        List&lt;Object&gt; Array = new ArrayList&lt;Object&gt;();        int n = Integer.parseInt(br.readLine());        int count =0;        int sum=0;        //1.        for(int i =0; i &lt; n; i++) {            Array.add(br.readLine());        }        //2.        String[] str;        for(Object aa : Array) {            count =0;            sum=0;            str = (aa.toString()).split(\"\");        //3.        for(String s : str) {            if(s.equals(\"O\")) {            sum\t+= ++count;            } else {            count =0;            }        }        bw.write(sum +\"\\n\");        }        br.close();        bw.flush();        bw.close();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/8958&gt;",
        "url": "/beakjoon-8958"
    }
    ,
    
    "jsp-bean-html": {
        "title": "bean",
            "author": "jaehong",
            "category": "",
            "content": "Java언어의 데이터(속성)과 기능(메소드)로 이루어진 클래스    useBean    setProperty    getPropertyuseBean특정 Bean을 사용한다고 명시 할떄 사용              //id(빈이름) , 클래스 이름 , 스코프 범위&lt;jsp:userBean id =\"student\" class=\"\"com.javalec.ex.Student scope=\"page\"/&gt;set,getPropertyjava s/getter와 같은 역할&lt;jsp:setProperty name=\"student\" property=\"name\" value=\"홍길동\"/&gt;&lt;jsp:getProperty name=\"student\" property=\"name\"/&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-bean.html"
    }
    ,
    
    "jsp-exception-html": {
        "title": "exception",
            "author": "jaehong",
            "category": "",
            "content": "예외처리1.페이지 지시자를 통한 예외 처리    &lt;%@ page errorPage = \"errorPage.jsp\" %&gt; //1. 해당페이지에서 에러가 발생할시 errorPage.jsp의 내용 출력&lt;%@ page isErrorPage = \"true\" %&gt; &lt;!-- 해당page는 error를 받을 수 있습니다.--&gt;&lt;% response.setStatus(200); %&gt; &lt;!-- 200은 정상적인 페이지를 말함--&gt;&lt;body&gt;    예외페이지 입니다.&lt;br/&gt;    &lt;% exception.getMessage(); %&gt;&lt;/body&gt;2.web.xml을 통한 예외 처리web.xml    &lt;error-page&gt;        &lt;error-code&gt;404&lt;/error-code&gt;        &lt;location&gt;/error404.jsp&lt;/location&gt;    &lt;/error-page&gt;    &lt;error-page&gt;        &lt;error-code&gt;500&lt;/error-code&gt;        &lt;location&gt;/error500.jsp&lt;/location&gt;    &lt;/error-page&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-exception.html"
    }
    ,
    
    "jsp-cookie-html": {
        "title": "cookie &amp; session &amp; cache",
            "author": "jaehong",
            "category": "",
            "content": "쿠키http 프로토콜의 특징은 웹브라우저에 응답 후 관계를 끊는 것이다.    연결이 끊겼을 때 어떤 정보를 지속적으로 유지하기 위한 수단으로 쿠키를 사용한다.    쿠키는 서버에서 생성하여, 생성된 쿠키는 서버가아닌 클라이언트 측에 저장     4kb로, 300개까지 데이터 정보를 가질 수 있다. 쿠키 생성 -&gt; 속성 설정 -&gt; response 객체에 쿠키 탑재    &lt;%    Cookie cookie = new Cookie(\"id\",id); //쿠키 name, value    cookie.setMaxAge(60); //60초간 지속    response.addCookie(cookie); //쿠키탑재    response.sendRedirect(\"abc.jsp\") // 포워딩    %&gt;&lt;!--forwarding 후--&gt;&lt;%    Cookie[] cookies = request.getCookies(); // 포워딩된 쿠키객체    for(int i=0; i &lt; cookies.length; i++){        String id = cookies[i].getValue();    } 쿠키의 한계 사용자가 임의로 고치거나 지울수있다. 쿠키가 보안상으로 취약 세션    쿠키와 마찬가지로 서버와의 관계를 유지하기 위한 수단    서버상에 객체로 존재 (쿠키는 클라이언트 쪽에 존재)    세션은 서버에서만 접근이 가능 -&gt; 보안이 좋다. , 데이터에 한계가 없다.브라우저 하나당 하나의 객체를 jsp 컨테이너가 자동으로 생성한다. 클라이언트 요청 -&gt; 서버에서는 기한이 짧은 임시키를 브라우저로보내어 쿠키로저장 -&gt; 클라이언트가 사이트 접속할때마다 http요청에 key를 실어 서버로 전송login.html&lt;form  action =\"loginOk.jsp\" method=\"post\"&gt;    아이디: &lt;input type=\"text\" name =\"id\" size=\"10\"&gt;&lt;br/&gt;    비밀번호: &lt;input type=\"password\" name =\"pw\" size=\"10\"&gt;&lt;br/&gt;    &lt;input type=\"submit\" value=\"로그인\"&gt;&lt;/form&gt;loginOk.jsp&lt;%!    String id,pw;%&gt;&lt;%    id =request.getParameter(\"id\");    pw = request.getParameter(\"pw\");    if(id.equals(\"abcde\")&amp;&amp; pw.equals(\"12345\")){        session.setAttribute(\"id\",id);        response.sendRedirect(\"welcome.jsp\");    }else{        response.sendRedirect(\"login.html\");    }%&gt;welcome.jsp&lt;%    Enumeration enumeration = session.getAttributeNames();    while(enumeration.hasMoreElements()){        String sName = enumeration.nextElement().toString();        String sValue = (String)session.getAttribute(sName);        if(sValue.equals(\"abcde\")){            out.println(sValue + \"님 안녕하세요.\" +\"&lt;br/&gt;\");        }    }%&gt;logout.jsp&lt;%    Enumeration enumeration = session.getAttributeNames();    while(enumeration.hasMoreElements()){    String sName = enumeration.nextElement().toString();    String sValue = (String)session.getAttribute(sName);    if(sValue.equals(\"abcde\")) session.removeAttribute(sName);    }%&gt;캐쉬가져오는데 비용이 드는 데이터를 한번가져온뒤에는 임시로 저장    웹캐쉬는 이미지정보를 불러올때 데이터사용량도 발생하고 시간도들기에    사용자가 여러번 방문 할듯한 사이트에서는 한번 받아온 데이터를 사용자의 컴퓨터 or 서버에 저장References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/    얄팍한 코딩사전",
        "url": "/jsp-cookie.html"
    }
    ,
    
    "jsp-action-tag-html": {
        "title": "action tag",
            "author": "jaehong",
            "category": "",
            "content": "액션태그JSP 페이지 내에서 동작을 지시하는 태그forward&lt;!-- main.jsp --&gt;&lt;jsp:foword page=\"sub.jsp\"/&gt;    url은 변경되지 않지만 내용은 forward한 .jsp파일을 따른다.include현재페이지에서 다른 페이지 삽입&lt;jsp:include page = \"include02.jsp\" flush =\"true\"/&gt;paramforward 및 include 태그에 데이터 전달을 목적으로 사용되는 태그&lt;jsp:foward page=\"sub.jsp\"&gt;    &lt;jsp:param name=\"id\" value =\"abcd\"/&gt;    &lt;jsp:param name=\"pw\" value=\"11\"/&gt;&lt;/jsp:foward&gt;&lt;!---값을 받을때-----&gt;&lt;%    id = request.getParameter(\"id\");    pw = request.getParameter(\"pw\");%&gt;References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-action-tag.html"
    }
    ,
    
    "beakjoon-1110": {
        "title": "더하기 사이클",
            "author": "jaehong",
            "category": "",
            "content": "더하기 사이클import java.io.*;public class Main {public static void main(String[] args) throws IOException{    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    int n =  Integer.parseInt(br.readLine());    int sum =0;    int leftN =0;    int rightN =0;    int result = n;    int a =0;    while(true) {        leftN = result/10;        rightN = result%10;        sum = leftN + rightN;        result = rightN*10 + sum%10;        a++;        if(n == result) {            break;        }    }    bw.write(a +\"\\n\");    bw.flush();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/1110&gt;",
        "url": "/beakjoon-1110"
    }
    ,
    
    "java-abstract-interface": {
        "title": "추상클래스와 인터페이스",
            "author": "jaehong",
            "category": "",
            "content": "추상실제들 간에 공통되는 특성을 추출ex) 삼성 현대 기아회사추상클래스    실제 클래스들의 공통되는 필드, 메소드를 정의한 클래스    공통된 필드와 메소드 이름을 통일할 목적    부모 클래스로만 사용 되며 , 객체 생성 불가    추상 메서드는 자식 클래스에서 오버라이딩! 인터페이스    인터페이스란 .. 개발코드와 객체가 서로 통신 하는 접점이다.    개발 코드는 객체의 내부구조를 몰라도 인터페이스의 메소드만 알고있으면된다.인터페이스 역할    개발 코드가 객체에 종속되지 않게 하여 객체를 교체 할 수 있도록 함.    개발 코드 변경없이 리턴 값 또는 실행 내용이 다양해 질수있다.(다형성)인터페이스 구성멤버    상수, 추상메소드    Java 8 부터는 default 메소드, 정적 메소드상수 필드 선언    인터페이스는 상수 필드만 선언가능    인터페이스에 선언된 모든 필드는 public static final(상수)의 특징을 가짐     상수명은 대문자    선언과 동시에 초기화 (static 블록을 작성할수없으므로}추상 메소드 선언    인터페이스의 메소드는 기본적으로 실행 블록이 없는 추상 메소드로 선언한다.    public abstract를 생략하더라도 컴파일 과정에서 자동적으로 붙음public interface RemoteControl{int MAX_VOLUME = 10;int MIN_VOLUME =0;public abstract void turnOn();void turnOff();\t//public abstract 생략void setVolume(int volume); //public abstract 생략}디폴트 메소드 선언    자바 8 에서 추가된 인터페이스의 새로운 멤버    [public]이 기본타입으로 default를 붙어야 생성된다.public interface RemoteControl{    default void setMute(boolean mute){    if(mute){        System.out.println(\"무음 처리\");    }else{        System.out.println(\"무음 해제\");    }}정적 메소드 선언public interface RemoteControl{    static void emptyBattery(){        System.out.println(\"배터리가 다 소모 되었습니다.\");    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-abstract-interface"
    }
    ,
    
    "beakjoon-2439": {
        "title": "별 찍기 -2",
            "author": "jaehong",
            "category": "",
            "content": "별찍기 2import java.io.*;public class Main {public static void main(String[] args) throws IOException {    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));    int n = Integer.parseInt(br.readLine());    int k = n;    for (int i = 0; i &lt; n; i++) {        for(int j=0; j &lt; n-i-1; j++ ) {          bw.write(\" \");        }         for (int j = 0; j &lt;= i; j++) {          bw.write(\"*\");        }        bw.write(\"\\n\");    }    br.close();    bw.flush();    bw.close();    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/2439&gt;",
        "url": "/beakjoon-2439"
    }
    ,
    
    "beakjoon-2748": {
        "title": "피보나치 수열2(fibonacci)",
            "author": "jaehong",
            "category": "",
            "content": "피보나치 수열2import java.util.Scanner;public class fibonacci {public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    int num = sc.nextInt();    long[] array = new long[num+1]; //int 범위(2,147,483,647)를 초과 long으로 선언    //고정되어있는 값대입    array[0] = 0;    array[1] = 1;    for(int i=2; i&lt; array.length; i++) {        array[i] = array[i-1] + array[i-2];    }    System.out.println(array[num]);    }}문제출처    백준알고리즘 https://www.acmicpc.net/problem/2748&gt;",
        "url": "/beakjoon-2748"
    }
    ,
    
    "jsp-servlet-3-html": {
        "title": "Servelt 3",
            "author": "jaehong",
            "category": "",
            "content": "Servlet 초기화 파라미터 : ServletConfig특정 Servlet 생성될 때 초기에 필요한 데이터들이 있다. ex)특정 경로 및 아이디 등..    이러한 데이터들을 초기화 파라미터라고 함1. web.xml 사용해서 초기화2. Servlet 파일 사용해서 초기화해당 Servlet에 @WebInitParam 사용해서 초기화ServletContext 모든 서블릿에  데이터를 공유 할 시 (web.xml에 기술)웹어플리케이션 생명주기 감시 : ServletContextListner xml 파일을 통해 Lisner 지정하거나 or 리스너클래스에 어노테이션 사용하거나순서References.References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-servlet-3.html"
    }
    ,
    
    "jsp-servlet-2-html": {
        "title": "Servelt 2",
            "author": "jaehong",
            "category": "",
            "content": "Servlet 작동순서클라이언트에서 servlet 요청이 들어오면 서버는     servlet 컨테이너를 만들고, 요청이 있을때 마다 스레드가 생성Servlet 라이프 사이클(생명주기)    한번생성된 객체는 재사용 -&gt; 요청이 필요할때마다 객체를 생성하는게 아니라서 속도빠름@PostConstruct 선처리: 객체생성과 init()호출사이의 단계에서 메소드 실행@PreDestroy 후처리: destroy() 호출 후에 메소드 실행HTML form 태그Form 태그의 submit 버튼을 클릭하여 데이터를 서버로 전송하면, 해당파일(Servlet)에서는 HttpRequest 객체를 이용하여 Parameter 값을 얻을 수 있다.form 태그에서 Servlet 까지 흐름도한글처리 방식References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-servlet-2.html"
    }
    ,
    
    "jsp-servlet-1-html": {
        "title": "Servelt 1",
            "author": "jaehong",
            "category": "",
            "content": "JSP는 무엇이고, Servlet 은 무엇인가?&lt;Servlet    Tomcat 위에서 동작하는 java Program .. 더 자세히는 Servlet이 초기화 되는 과정을 보면    Java 코드 안에 HTML 코드 (하나의 클래스) .. JSP는 반대JSP , Servlet 차이Servlet    Java 코드 안에 HTML 코드 (하나의 클래스)    data processing(Controller)에 좋다.    Servlet이 수정된 경우 Java 코드를 컴파일(.class 파일 생성)한 후 동적인 페이지를 처리하기 때문에 전체 코드를 업데이트하고 다시 컴파일한 후 재배포하는 작업이 필요하다. (개발 생산성 저하)JSP    Java 언어를 기반으로 하는 Server Side 스크립트 언어    HTML 코드 안에 Java 코드    Servlet를 보완하고 기술을 확장한 스크립트 방식 표준        Servlet의 모든 기능 + 추가적인 기능Servlet 클래스는 HttpServlet 클래스를 상속받음public class HelloWorld extends HttpServlet{}요청처리 및 응답처리객체를 톰캣에서 받음protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {//request 요청처리객체, response 응답처리 객체response.setContentType(\"text/html\"); //응답 처리시 html로PrintWriter writer = response.getWriter();GET방식 &amp; POST방식클라이언트에서 WAS로 요청(request)하는 2가지 방법html 태그안에 method = GET or POST 정함1.GET 방식    서블릿에서 doGet 메소드 호출    서버에는 최대 240Byte까지 데이터를 전달할 수 있다.    URL값이 노출되어 보안취약2.POST 방식    서블릿에서 doPost 메소드 호출    서버에 전달할 수 있는 데이터 크기에 제한이 없다.    URL에는 매개변수가 표시되지않는다. 깨달은것 response.setContentType(\"text/html\"); 이부분을 잘못입력하면response.setContentType(\"html/text\"); 이렇게입력시 실행시키면 웹페이지가 안뜨고 파일을 다운로드 받을 수도있다.Context PathWAS에서 웹어플리케이션을 구분하기 위한 path   이클립스에서 프로젝트생성시  자동으로 server.xml에 추가 References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-servlet-1.html"
    }
    ,
    
    "jsp-introduce-html": {
        "title": "jsp 입문",
            "author": "jaehong",
            "category": "",
            "content": "JSP    프로토콜 : 네트워크상에서 약속한 통신 규약     (Http:웹 통신규약, FTP: 서버에 파일 올리거나 받을때 , SMTP,POP: 메일 DHCP: 가정에서 사용하는 동적 사설 인터넷)    IP: 네트워크 상에서 컴퓨터를 식별할수있는 주소     DNS: IP주소를 인간이 쉽게 외우도록 맵핑한 문자열     Port: 해당 컴퓨터의 구동되고있는 프로그램을 구분할 수 있는 번호 (default로 80)Java 웹    JSP(java Server Page): HTML 파일 내에 JAVA언어를 삽입한 문서    Servlet(Server Applet) JAVA언어로 이루어진 웹프로그래밍 문서    컴포넌트: JSP, Servlet, HTML 등의 웹 어플리케이션을 구현하기 위한 구성요소Jsp 아키텍쳐Servlet 특징    동적 웹어플리케이션 컴포넌트    .java 확장자    java thread 이용하여 동작    MVC패턴에서 Controller맵핑 방법왜 맵핑을하는가?(Why) :너무 길고, 보안에 노출될수 있기에..    기존경로: http://localhost:8090/hello/servelt/com.javalec.ex.Helloworld    URL맵핑시: http://localhost:8090/hello/HWrold    MVC패턴에서 Controller1. web.xml 이용하는방법&lt;servlet&gt;    &lt;servlet-name&gt;helloworld&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.javalec.ex.HelloWorld&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;helloworld&lt;/servlet-name&gt;    &lt;url-pattern&gt;/hw&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;    servlet-name : 임의의 이름을 만듬    servlet-class : 매핑할 클래스 파일명을 패키지명을 포함하여 입력    url-parttern: servlet-class의 매핑할 임의의 이름입력. 반드시 /로시작해야됨!2. java code의 어노테이션 이용@WebServlet(\"/HWorld!!\")// servlet 상단에 선언 web.xml과 어노테이션 동시사용시 web.xml이 적용된다.  References.            https://www.youtube.com/watch?v=Aw-lOlR0I28&amp;list=PLOJ3X9PwqLzvyIx3mwuf-muEd5TUI-yph/",
        "url": "/jsp-introduce.html"
    }
    ,
    
    "java-inheritance": {
        "title": "상속",
            "author": "jaehong",
            "category": "",
            "content": "            자식(하위) 클래스가 부모(상위) 클래스의 멤버를 물려받는 것        상속 대상 : 부모의 필드 &amp; 메소드        개발 시간 단축, 객체의 다형성 구현, 코드의 중복성 다운, 유지보수 등 이점!!    상속 대상의 제한    부모클래스의 private 접근 제한을 가지는 필드와 메소드는 제외    부모클래스가 다른 패키지에 있을때 default 접근 제한을 가지는 필드와 메소드는 제외extends 키워드    부모클래스를 상속받기위한 키워드    자바는 다중상속을 허락하지 않아 한클래스에 하나만 상속가능자식 객체를 생성하면 부모 객체도 생성될까?정답은 생성된다!!    자식 객체 생성시 부모 객체부터 생성되고 자식 객체가 생성된다.    부모 생성자가 호출이 완료되고 자식 생성자가 나중에 호출 완료된다.    자식 생성자가 부모생성자를 호출 하지 않아도 컴파일러가 자동적으로 super()를 통해 부모의 기본생성자를 호출 부모 생성자 호출 super()    super(매개값)은 매개값과 동일한 타입, 개수, 순서가 맞는 부모 생성자 호출    부모 클래스에 기본생성자가 없다면 필수적으로 부모클래스에 맞는(매개변수) 생성자를 작성해야된다.    반드시 자식생성자 첫 줄에 위치 해야된다.    자식 생성자를 호출해서 자식객체를 생성시 부모 객체의 생성자 부터 호출한다.!!public Student(String name, String ssn, int studentNo) {this.studentNo =studentNo;super(\"jaehong\",\"93-12-23\"); //컴파일오류.. 이유: 생성자의 첫줄에서 선언해주어야함!}Override 매소드 재정의    부모 클래스의 메소드를 자식 클래스에서 재정의 하는 것을 말한다.    접근 제한을 더 강하게 오버로딩 할 수 없다. ex) public -&gt; private, default (X) 반대로는 가능@Override 어노테이션     컴파일러에게 부모 클래스의 메소드와 선언부와 동일한지 검사하도록 지시    접근 제한을 더 강하게 오버로딩 할 수 없다. ex) public -&gt; private, default (X) 반대로는 가능    super.부모메소드() : 부모메소드 호출방법다형성(Ployorphism)    같은 타입이지만 실행결과가 다양한 객체를 대입할수있는 성질을 말한다.    A a = new B() //b는 부모객체 A클래스를 상속 받고있는 상태    자식 타입은 부모타입으로 자동 타입 변환된다.    객체를 부품화시킨다.! (타이어 예시 생각!)    부모 클래스 변수 = 자식클래스타입 부모 클래스 변수는 자식과 같은 주소를 가진다.자동 타입 변환 이후 효과    부모 클래스에 선언된 필드와 메소드만 접근 가능    자식 클래스의 재정이된 메소드가 호출된다. (다형성관련)class Parent{    void method1(){};    void method2(){}; // 1번 !!!!!!!!!}////////////////////class Child extends Parent{    void method2(){..}//Overrideing // 2번 !!!!!!!!!    void method3(){}}class ChildEx{    public static void main(String args[]){        Child child = new Child();        Parent parent = child; //Parent로 자동 타입 변환        parent.method1();        parent.method2(); // 부모타입으로 형변환이 됬지만 1번이 아닌 오버라이딩된 2번이 실행된다!! 중요        parent.method3(); // 호출불가능    }}자식 타입인지 확인후 강제 타입instanceofpublic void method(Parent parent) {    if (parent instanceof Child) { //매개변수로 들어오는 객체가 Child 인지확인        Child Child = (Child) parent;    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-inheritance"
    }
    ,
    
    "java-no-parameter-number": {
        "title": "메소드에서 매개변수의 수를 모르는 경우",
            "author": "jaehong",
            "category": "",
            "content": "메소드에서 매개변수의 수를 모르는 경우    메소드에서 여러개의 매개변수를 넘기는 경우 배열을 이용    매개변수의 수가 몇개가 들어올지 모를때에 '...'을 사용함으로 넘겨받는 값의 수에 따라 자동으로 배열 생성public class Parameter {    public static void main(String args[]) {        Cal cal = new Cal();        int[] data = new int[] {1,2,3};        System.out.println(\"sum1 : \" + cal.sum1(data));        System.out.println(\"sum2 : \" + cal.sum2(1,2,3));        System.out.println(\"sum2 : \" + cal.sum2(1,2,3,4,5));    }}class Cal{    int sum1(int[] n) {    int sum=0;        for(int i :n) {        sum += i;        }    return sum;    }    int sum2(int ... n) { //매개변수의 개수를 모를때    int sum=0;    for(int i : n) {    sum += i;    }    return sum;    }}",
        "url": "/java-no-parameter-number"
    }
    ,
    
    "java-annotation": {
        "title": "어노테이션 (Annotation)",
            "author": "jaehong",
            "category": "",
            "content": "프로그램에게 추가적인 정보를 제공해주는 메타데이터(metadata)이다.    컴파일러에게 코드 작성 문법에러 체크하도록 정보제공                                    ex) Override                            개발 툴이 빌드나 배치시 코드를 자동으로 생성할 수 있도록 정보 제공                                    ex) XML 설정 파일을 자동 생성한다거나 배포를 위한 JAR 압축 파일을 자동생성가능                            실행시(런타임시) 특정 기능을 실행하도록 정보 제공                                    ex) Servlet 이나 Controller 객체 사용시                        기본 엘리먼트 valuepublic @interface AnnotationName{String value;int elementName() default 5;}어노테이션을 적용할때 엘리먼트명을 생략가능        @AnnotationName(\"값입니다\") //value에 \"값입니다\" 저장두개 이상의 속성을 기술할때는 value=값 형태로 기술    @AnnotationName(value=\"값입니다\", elementName = 4);어노테이션 적용대상    java.lang.annotationElementType 열거 상수로 정의어노테이션 적용 대상 방법    @Target 어노테이션으로 적용대상지정//예시@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})public @interface AnnotationName{}어노테이션 유지정책    어노테이션 적용 코드가 언제까지 유지될것인가를 기술한것    java.lang.annotation.RetentionPolicy 열거 상수로 정의되어 있음                RetenionPolicy 열거 상수        설명                        SOURCE        바이트코드에서는 어노테이션이 유지되지 않는 정책, 개발자가 소스에서어떤 정보를 얻을 목적으로 유지하는 정책                CLASS        컴파일러가 바이트 코드를 만들때 까지는 유지그러나 어노테이션의 값을 클래스 실행시 얻을 수 없다.클래스상에서만 존재하고 실제 실행시 정보를 읽지 못하는 정책                RUNTIME        바이트 코드 까지 유지가 되고 바이트 코드파일을 로딩을 시키고 나서 실제프로그래밍 실행시 어노테이션의 정보를 읽고 이용을 할 수 있도록 하는 유지정책 대부분사용        리플렉션(reflection): 런타임에 클래스의 메타 정보를 얻는 기능    클래스가 가진 필드, 생성자, 메소드, 어노테이션 정보을 얻을 수 있다.    Runtime(실행중에) 어노테이션 정보를 얻으려면 유지 정책을 RUNTIME으로 설정해야됨유지 정책 지정방법    @Retention 어노테이션으로 유지정책을 지정    @Retention의 기본 엘리먼트인 value의 타입은 RetentionPolicy@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationName{}References.    https://www.hanbit.co.kr/",
        "url": "/java-annotation"
    }
    ,
    
    "java-getter-setter": {
        "title": "Getter와 Setter",
            "author": "jaehong",
            "category": "",
            "content": "     Getter            일반적으로 클래스선언시 필드는 prvite 접근제한을 한다.   (외부로 부터 변경을 막기위해)        때에 따라서 필드를 읽기만 하기 위해 Getter를 사용한다.        Getter는 private 필드를의 값을 리턴 하는 구현기술 중 하나이다.        getFieldName() 또는 isFieldName() 메소드의 이름을 가진다.        Field 타입이 boolean 일경우 isFieldName()로 나머지는 getFieldName()이 된다.              Setter            외부에서 필드의 값을 수정할 때에 올바른 값만 필드에 저장할 수 있도록 도와준다.        필요할경우 유효성검사 가능        setFiledName(타입변수)             CODE     123456789101112131415161718private&nbsp;int&nbsp;num;&nbsp;public&nbsp;int&nbsp;getNum()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;num;}public&nbsp;void&nbsp;setNum(int&nbsp;num){&nbsp;&nbsp;&nbsp;&nbsp;this.num&nbsp;=&nbsp;num;}//---------------------------------private&nbsp;Boolean&nbsp;success;&nbsp;public&nbsp;Boolean&nbsp;isSuccess(){&nbsp;&nbsp;&nbsp;&nbsp;//boolean&nbsp;일때는&nbsp;is&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;success;}&nbsp;public&nbsp;void&nbsp;setSuceess(Boolean&nbsp;success){&nbsp;&nbsp;&nbsp;&nbsp;this.success&nbsp;=&nbsp;success;}&nbsp;Colored by Color ScriptercsReferences.    https://www.hanbit.co.kr/",
        "url": "/java-getter-setter"
    }
    ,
    
    "java-access-modifier": {
        "title": "접근 제한자(Access Modifier)",
            "author": "jaehong",
            "category": "",
            "content": "    클래스       제한    생성자       제한    필드와 메소드 제한publicprotected            같은패키지:default와 동일        다른패키지:자식클래스만 접근 허용상속의 개념과 연관        클래스 앞에는 선언할수없다. 필드 메서드 생성자는 가능    defaultprivateReferences.    https://www.hanbit.co.kr/",
        "url": "/java-access-modifier"
    }
    ,
    
    "java-pakage": {
        "title": "패키지(Pakage)",
            "author": "jaehong",
            "category": "",
            "content": "    상위 패키지와 하위 패키지는 도트(.)로 구분    패키지이름은 소문자 &amp;&amp; 숫자,특수문자 안됨 &amp;&amp; 도메인 역순(com.naver.projectname) 명령 라인 환경에서(CLI) 컴파일&lt;ul&gt;    &lt;li&gt;javac XXX.java &lt;-- 이 명령어로 컴파일시 .class는 생기나 패키지는 자동으로 생성안됨&lt;/li&gt;    &lt;li&gt;javac -d [패키지가 생성될위치] xxx.java &lt;-- -d 옵션으로 패키지 생성될 위치 &lt;/li&gt;    &lt;li&gt;클래스파일 실행 명령어 -&gt; ex) C:\\eclispe-workspace\\Test\\bin&gt; java com.test.Calculator  &lt;/li&gt;&lt;/ul&gt;References.    https://www.hanbit.co.kr/",
        "url": "/java-pakage"
    }
    ,
    
    "java-final": {
        "title": "final (field,Static final(상수),&lt;br&gt; Class, Method)",
            "author": "jaehong",
            "category": "",
            "content": "            한번의 초기화로 인하여 값을 변경할수 없는 필드        메서드를 호출해서 객체가 사용할수있도록 준비하는 역할 수행         CODE public class Person {    final String nation = \"kr\"; //값을 초기에 할당하거나    final String ssn;    public Person(String ssn) {//생성자 선언시 할당하거나    this.ssn = ssn;              //final은 최초한번만 값대입가능    }} 상수 (Static final)              final 필드가 객체 마다 가지는 인스턴스 필드라고 하면         상수는 객체마다 가지고있지 않고 메소드 영역에서 클래스별로 관리되는 정적 필드        공용데이터로 관리         CODE     static final dobule EARTH_RADIUS = 6400;    //상수의 이름은 전부 대문자로 작성 단어와 연결시 _(언더바)    static final double EARTH_SURFACE_AREA;    static{    EARTH_SURFACE_AREA = 4 * Math.PI *  EARTH_RADIUS *  EARTH_RADIUS;}final 클래스    상속과 연관    부모로 사용할 수 없는 클래스     CODE     public final class A{} //A라는 final 클래스가 있을때    ///////////////////////////////////////////////    public class B extends A{} // A클래스가 final 클래스로 선언되어있어 상속을 받지못함 컴파일에러 발생final 메소드    상속과 연관    자식이 재정의할 수 없는 메소드     CODE public class Car{    public int speed;    public  void speedUp(){        speed += 1;    }    public final void stop(){   //메소드도 final 클래스와 마찬가지로 final 메소드인 stop을 override하려고하면 컴파일 에러발생!        System.out.println(\"차를 멈춤\");        speed =0;    }}References.    https://www.hanbit.co.kr/",
        "url": "/java-final"
    }
    ,
    
    "dp-singletonpattern": {
        "title": "싱글톤 패턴(Singleton-Pattern)",
            "author": "jaehong",
            "category": "",
            "content": "디자인 패턴(Design Pattern List)            싱글톤 패턴 (Singleton pattern)         싱글턴(Singleton) 이란 ?                     싱글턴 패턴은 인스턴스가 오직 1개만 생성되야 하는 경우에 사용되는 패턴입니다.             예를들어 레지스트리 같은 설정 파일의 경우 객체가 여러개 생성되면 설정 값이 변경될 위험이 생길 수 있습니다.                 인스턴스가 1개만 생성되는 특징을 가진 싱글턴 패턴을 이용하면, 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로, 요청이 많은 곳에서 사용하면 효율을 높일 수 있습니다.    주의 해야할 점은 싱글턴을 만들때 동시성(Concurrency) 문제를 고려해서 싱글턴을 설계해야합니다.References.    https://medium.com/webeveloper",
        "url": "/dp-singletonPattern"
    }
    ,
    
    "dp-design-pattern": {
        "title": "디자인 패턴 리스트(Design-Pattern-List)",
            "author": "jaehong",
            "category": "",
            "content": "디자인 패턴(Design Pattern List)            싱글톤 패턴 (Singleton pattern)    ",
        "url": "/dp-design-pattern"
    }
    ,
    
    "java-constructor": {
        "title": "생성자(Constructor)",
            "author": "jaehong",
            "category": "",
            "content": "     new 클래스();                    필드의 값을 설정하거나            메서드를 호출해서 객체가 사용할수있도록 준비하는 역할 수행                 생성자(Constractor)References.    https://www.hanbit.co.kr/",
        "url": "/java-constructor"
    }
    ,
    
    "jekyll-basic": {
        "title": "처음만든날",
            "author": "jaehong",
            "category": "",
            "content": "블로그처음만든날",
        "url": "/jekyll-basic"
    }
    ,
    
    "java-basic": {
        "title": "java 강좌(1) - java 기본",
            "author": "jaehong",
            "category": "",
            "content": "이글은 java에 관한 내용이 있습니다.11",
        "url": "/java-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://JaeHong2.github.io//">오늘의 공부기록</a> &copy; 2021</section>
                <section class="poweredby">

                    <a href="https://github.com/jaehong2" target="_blank" rel="noopener">GitHub</a>
                </section>
                <nav class="site-footer-nav">
                    <a></a>
                    <a>본 홈페이지는 개인공부 페이지입니다.</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search</h1>
            <p class="subscribe-overlay-description">
                검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>

    <!-- 2020년 404 에러나서 12-25일 주석처리함-->
    <!--<script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script> -->


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
